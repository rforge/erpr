scalp(list(word), smo=0, layout=1, ylim=10)
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
?scalp.infl
erp.infl <-#
function(base, numbers, electrode, smo=0, startmsec=-200, endmsec=1200, lwd=1, lty=1, envir=.GlobalEnv, ...){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
erp.infl.panel=function(panel)#
	{#
#
		erp.infl.endo=function(base, numbers, electrode, outline, smo=0 , col="black", startmsec=-200, endmsec=1000, interval=c(startmsec, endmsec), step=200, verticals=NULL,horizontals=NULL, x.axis="default", ylim=c(-10,10), lwd=1, lty=1,out.col="red", envir)#
	{#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],"$",electrode, sep="")), envir=envir)#
		for (i in 2:length(numbers))#
		{#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i],"$",electrode, sep="")), envir=envir)		#
		}#
		average=average.temp/length(numbers)#
		erp(average,smo=smo, col=col, startmsec=startmsec, endmsec=endmsec, interval=interval,step=step, verticals=verticals, horizontals=horizontals, x.axis=x.axis, ylim=ylim, lwd=lwd, lty=lty,main=electrode, ...)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline,"$",electrode, sep="")), envir=envir))/(length(numbers)-1)#
		erp.add(average.excl, col=out.col, lwd=2, smo=smo)#
	legend("topright", legend=c("Average all", paste("Average no subj", outline)), pch=15, col=c(col,out.col), pt.bg=c(1:6), cex=1.2)#
		}							#
		erp.infl.endo(base=base, numbers=numbers, electrode=electrode, outline=panel$outnumber, smo=smo, startmsec=startmsec, endmsec=endmsec, envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = erp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, erp.infl.panel)#
   }
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("axes","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("axes","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("axes","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout==4){#
		electrodes=c("axes", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout==5){#
		electrodes=c("axes", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
	plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
		for (i in 2:(length(electrodes))){#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]!="blank"&electrodes[i]!="axes"&electrodes[i]!="legend") {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))
scalp(list(nonword), smo=0, layout=1, ylim=10)
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))
Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1
Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
temp="\code{data.frame}"
temp="\\code{data.frame}"
temp
curr.dir="~/Desktop/R files/erpr/pkg/R"#
setwd(curr.dir)#
#
files=dir()
i=1
files
files[i]
i)4
i=4
temp=readLines(files[i])
temp
curr.dir="~/Desktop/R files/erpr/pkg/man"
setwd(curr.dir)
files=dir()
i=4
temp=readLines(files[i])
temp
temp=gsub("\\code{data.frame}", "data frame", temp)
?erp.mean
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long")
head(dat)
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="wide")
head(dat)
curr.dir="~/Desktop/R files/erpr/pkg/man"#
setwd(curr.dir)#
#
files=dir()#
#
dir.create(paste("../nuovoman", sep=""))#
#
for (i in 1:length(files)){#
	temp=readLines(files[i])#
	temp=gsub("comment.dat", "fileinfo", temp)#
	writeLines(temp, paste("../nuovoman/", files[i],sep=""))#
}
curr.dir="~/Desktop/R files/erpr/pkg/R"#
setwd(curr.dir)#
#
files=dir()#
#
dir.create(paste("../nuovoman", sep=""))#
#
for (i in 1:length(files)){#
	temp=readLines(files[i])#
	temp=gsub("comment.dat", "fileinfo", temp)#
	writeLines(temp, paste("../nuovoman/", files[i],sep=""))#
}
citation("erpR")
rm(list=ls())
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "condition", "Electrode")]=factorall(dat400600[,c("Subject", "condition", "Electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])
factorall
datmidline
str(datmidline)
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])
str(datmidline)
remove.packages("erpR")
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
factorall
detach(package:erpR)
remove.packages("erpR")
library(erpR)
?erpR
?create.mean
library(erpR)
?factorall
library(erpR)
scalp <-#
function(categ, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=1, lty=1, color.list=c("blue", "red", "darkgreen"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
legend.lab=deparse(substitute(categ))#
legend.lab=gsub("\\(", "",legend.lab)#
legend.lab=gsub("\\)", "", legend.lab)#
legend.lab=gsub("^list", "", legend.lab)#
legend.lab=gsub(" ", "", legend.lab)#
legend.lab=unlist(strsplit(legend.lab, ","))#
}#
#
if (length(lwd)==1){#
	lwd=rep(lwd, length(categ))}#
if (length(lty)==1){#
	lty=rep(lty, length(categ))}#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
if (layout==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos=dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	for (i in 2:(length(electrodes))){#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
			plot.new()#
			if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=msectopoints(0, dim(categ[[1]])[1], startmsec=startmsec, endmsec=endmsec)#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
	if (length(categ)>1&electrodes[i]!="blank") {#
				for (k in 2:length(categ)){#
					lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
					}#
		} #
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
}
scalp
?scalp
word=grandaverage("Exp1_word_subj", 1:20)#
#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
#
scalp(list(word), smo=0, layout=1, ylim=10)#
#
scalp(list(word, nonword), smo=0, layout=1, ylim=10, legend=T)
data(ERPsets)
word=grandaverage("Exp1_word_subj", 1:20)#
#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
#
scalp(list(word), smo=0, layout=1, ylim=10)#
#
scalp(list(word, nonword), smo=0, layout=1, ylim=10, legend=T)
scalp
electrodes=c("xaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")
word=grandaverage("Exp1_word_subj", 1:20)#
#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
#
scalp(list(word), smo=0, layout=electrodes, ylim=10)
scalp
electrodes=c("xaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")
scalp <-#
function(categ, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=1, lty=1, color.list=c("blue", "red", "darkgreen"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
legend.lab=deparse(substitute(categ))#
legend.lab=gsub("\\(", "",legend.lab)#
legend.lab=gsub("\\)", "", legend.lab)#
legend.lab=gsub("^list", "", legend.lab)#
legend.lab=gsub(" ", "", legend.lab)#
legend.lab=unlist(strsplit(legend.lab, ","))#
}#
#
if (length(lwd)==1){#
	lwd=rep(lwd, length(categ))}#
if (length(lty)==1){#
	lty=rep(lty, length(categ))}#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
if (layout==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos=dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	for (i in 2:(length(electrodes))){#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
			plot.new()#
			if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=msectopoints(0, dim(categ[[1]])[1], startmsec=startmsec, endmsec=endmsec)#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
	if (length(categ)>1&electrodes[i]!="blank") {#
				for (k in 2:length(categ)){#
					lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
					}#
		} #
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
}
electrodes=c("xaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")
scalp(list(word), layout=electrodes)
scalp
scalp(list(word), layout=electrodes)
scalp <-#
function(categ, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=1, lty=1, color.list=c("blue", "red", "darkgreen"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
legend.lab=deparse(substitute(categ))#
legend.lab=gsub("\\(", "",legend.lab)#
legend.lab=gsub("\\)", "", legend.lab)#
legend.lab=gsub("^list", "", legend.lab)#
legend.lab=gsub(" ", "", legend.lab)#
legend.lab=unlist(strsplit(legend.lab, ","))#
}#
#
if (length(lwd)==1){#
	lwd=rep(lwd, length(categ))}#
if (length(lty)==1){#
	lty=rep(lty, length(categ))}#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos=dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
			plot.new()#
			if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=msectopoints(0, dim(categ[[1]])[1], startmsec=startmsec, endmsec=endmsec)#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
	if (length(categ)>1&electrodes[i]!="blank") {#
				for (k in 2:length(categ)){#
					lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
					}#
		} #
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
}
scalp(list(word), layout=electrodes, scalp.array=c(7,5))
scalp.t <-#
function(base1, base2, numbers1, numbers2=NULL, paired=TRUE, alpha=0.05, sig=NULL, envir=.GlobalEnv, envir2=NULL, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), color.list=c("blue", "red"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200)) {#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
	legend.lab=c(base1, base2)#
}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(numbers2)){#
	numbers2=numbers1}#
#
if (is.null(envir2)){#
	envir2=envir}#
#
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers1)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base1,numbers1[i1], sep="")),envir=envir)#
	}#
for (i2 in 1:length(numbers2)){#
	alldata2.list[[i2]]=eval(parse(file="", text=paste(base2,numbers2[i2], sep="")),envir=envir2)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
###############
cat("t-test results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		temp2=lapply(alldata2.list, function(x) { element(x,k) } )#
		temp2.1=matrix(unlist(temp2), ncol=length(alldata1.list[[1]]), byrow=TRUE) #di ciascuna riga una #
		#matrice con n righe (una per soggetto) e k colonne (una per elettrodo) #
		alltemp[[k]][[1]]=temp1.1#
		alltemp[[k]][[2]]=temp2.1#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.results.vet[j]=(t.test(alltemp[[k]][[1]][,j], alltemp[[k]][[2]][,j], corr=F, paired=paired)$p.value)<alpha#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base1 = le prime lettere degli oggetti #
#numbers1= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base1, numbers1, envir=envir)#
alldata2=grandaverage(base=base2,numbers2, envir=envir2)#
#
categ=list(alldata1,alldata2)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
	if (layout==4){#
    electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}		#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività#
			#######################
			abline(v=grep(TRUE,alltemp.results[,electrodes[i]]), col="lightgray")#
			########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=color.list[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
					lines(smooth.spline(categ[[2]][[electrodes[i]]], spar=smo),col=color.list[2], lwd=lwd[2],lty=lty[2])#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
scalp.t <-#
function(base1, base2, numbers1, numbers2=NULL, paired=TRUE, alpha=0.05, sig=NULL, envir=.GlobalEnv, envir2=NULL, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), color.list=c("blue", "red"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200)) {#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
	legend.lab=c(base1, base2)#
}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(numbers2)){#
	numbers2=numbers1}#
#
if (is.null(envir2)){#
	envir2=envir}#
#
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers1)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base1,numbers1[i1], sep="")),envir=envir)#
	}#
for (i2 in 1:length(numbers2)){#
	alldata2.list[[i2]]=eval(parse(file="", text=paste(base2,numbers2[i2], sep="")),envir=envir2)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
###############
cat("t-test results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		temp2=lapply(alldata2.list, function(x) { element(x,k) } )#
		temp2.1=matrix(unlist(temp2), ncol=length(alldata1.list[[1]]), byrow=TRUE) #di ciascuna riga una #
		#matrice con n righe (una per soggetto) e k colonne (una per elettrodo) #
		alltemp[[k]][[1]]=temp1.1#
		alltemp[[k]][[2]]=temp2.1#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.results.vet[j]=(t.test(alltemp[[k]][[1]][,j], alltemp[[k]][[2]][,j], corr=F, paired=paired)$p.value)<alpha#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base1 = le prime lettere degli oggetti #
#numbers1= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base1, numbers1, envir=envir)#
alldata2=grandaverage(base=base2,numbers2, envir=envir2)#
#
categ=list(alldata1,alldata2)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
	if (layout==4){#
    electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}		#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività#
			#######################
			abline(v=grep(TRUE,alltemp.results[,electrodes[i]]), col="lightgray")#
			########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=color.list[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
					lines(smooth.spline(categ[[2]][[electrodes[i]]], spar=smo),col=color.list[2], lwd=lwd[2],lty=lty[2])#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
?scalp.t
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, #
layout=electrodes, ylims=10, startmsec=-200, endmsec=1500, color.list=c("blue", "red"))
scalp.t <-#
function(base1, base2, numbers1, numbers2=NULL, paired=TRUE, alpha=0.05, sig=NULL, envir=.GlobalEnv, envir2=NULL, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), color.list=c("blue", "red"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL) {#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
	legend.lab=c(base1, base2)#
}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(numbers2)){#
	numbers2=numbers1}#
#
if (is.null(envir2)){#
	envir2=envir}#
#
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers1)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base1,numbers1[i1], sep="")),envir=envir)#
	}#
for (i2 in 1:length(numbers2)){#
	alldata2.list[[i2]]=eval(parse(file="", text=paste(base2,numbers2[i2], sep="")),envir=envir2)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
###############
cat("t-test results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		temp2=lapply(alldata2.list, function(x) { element(x,k) } )#
		temp2.1=matrix(unlist(temp2), ncol=length(alldata1.list[[1]]), byrow=TRUE) #di ciascuna riga una #
		#matrice con n righe (una per soggetto) e k colonne (una per elettrodo) #
		alltemp[[k]][[1]]=temp1.1#
		alltemp[[k]][[2]]=temp2.1#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.results.vet[j]=(t.test(alltemp[[k]][[1]][,j], alltemp[[k]][[2]][,j], corr=F, paired=paired)$p.value)<alpha#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base1 = le prime lettere degli oggetti #
#numbers1= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base1, numbers1, envir=envir)#
alldata2=grandaverage(base=base2,numbers2, envir=envir2)#
#
categ=list(alldata1,alldata2)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
	if (layout[1]==4){#
    electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}		#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="xaxis"&electrodes[i]!="legend") {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività#
			#######################
			abline(v=grep(TRUE,alltemp.results[,electrodes[i]]), col="lightgray")#
			########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=color.list[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
					lines(smooth.spline(categ[[2]][[electrodes[i]]], spar=smo),col=color.list[2], lwd=lwd[2],lty=lty[2])#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, #
layout=electrodes, ylims=10, startmsec=-200, endmsec=1500, color.list=c("blue", "red"))
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
)#
	plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
		for (i in 2:(length(electrodes))){#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]!="blank"&electrodes[i]!="yaxis"&electrodes[i]!="legend") {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
		for (i in 2:(length(electrodes))){#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]!="blank"&electrodes[i]!="yaxis"&electrodes[i]!="legend") {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
?scalp.infl
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=electrodes, startmsec=-200, endmsec=1500)
electrodes
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]!="blank"&electrodes[i]!="yaxis"&electrodes[i]!="legend") {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=electrodes, startmsec=-200, endmsec=1500)
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=1, startmsec=-200, endmsec=1500)
a="ciao"
c("miao", "bao", "zao")%in%a
a%in%c("ciao", "miao", "zao")
a%in%c("priao", "miao", "zao")
scalp <-#
function(categ, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=1, lty=1, color.list=c("blue", "red", "darkgreen"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
legend.lab=deparse(substitute(categ))#
legend.lab=gsub("\\(", "",legend.lab)#
legend.lab=gsub("\\)", "", legend.lab)#
legend.lab=gsub("^list", "", legend.lab)#
legend.lab=gsub(" ", "", legend.lab)#
legend.lab=unlist(strsplit(legend.lab, ","))#
}#
#
if (length(lwd)==1){#
	lwd=rep(lwd, length(categ))}#
if (length(lty)==1){#
	lty=rep(lty, length(categ))}#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos=dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
			plot.new()#
			if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=msectopoints(0, dim(categ[[1]])[1], startmsec=startmsec, endmsec=endmsec)#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
	if (length(categ)>1&electrodes[i]!="blank") {#
				for (k in 2:length(categ)){#
					lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
					}#
		} #
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
}
scalp(list(word), layout=electrodes, scalp.array=c(7,5))
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=1, startmsec=-200, endmsec=1500)
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=electrodes, startmsec=-200, endmsec=1500)
electrodes
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
			if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=electrodes, startmsec=-200, endmsec=1500)
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
electrodes
electrodes[1]="blank"
data(ERPdatasets)#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=electrodes, startmsec=-200, endmsec=1500)
electrodes
length(electrodes)
scalp.cor <-#
function(base, numbers, behaviour=NULL, alpha=0.05,method = c("pearson", "kendall", "spearman"), sig=NULL, envir=.GlobalEnv, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), col="blue", legend=TRUE, legend.lab="default", scalp.array=NULL) {#
#
if (legend.lab=="default"){#
	legend.lab=c(base)#
	}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base,numbers[i1], sep="")),envir=envir)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
#####################
#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], behaviour, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base = le prime lettere degli oggetti #
#numbers= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base, numbers, envir=envir)#
#
categ=list(alldata1)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
	if (layout==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8")#
		}#
	if (layout==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}	#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
	if (layout==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=col, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=col#
			}#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="yaxis"&electrodes[i]!="legend") {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=col[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrodes[i]]), col="lightblue", lwd=1)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrodes[i]]), col="indianred1", lwd=1)#
		########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=col[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
electrodes=gsub("xaxis", "Fp1", electrodes)
?scalp.cor
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=1, ylim=10, legend=T)
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electodes, ylim=10, legend=T)
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electrodes, ylim=10, legend=T)
scalp.cor <-#
function(base, numbers, behaviour=NULL, alpha=0.05,method = c("pearson", "kendall", "spearman"), sig=NULL, envir=.GlobalEnv, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), col="blue", legend=TRUE, legend.lab="default", scalp.array=NULL) {#
#
if (legend.lab=="default"){#
	legend.lab=c(base)#
	}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base,numbers[i1], sep="")),envir=envir)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
#####################
#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], behaviour, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base = le prime lettere degli oggetti #
#numbers= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base, numbers, envir=envir)#
#
categ=list(alldata1)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
	if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}	#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
	if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=col, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=col#
			}#
		}#
		if (electrodes[i]!="blank"&electrodes[i]!="yaxis"&electrodes[i]!="legend") {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=col[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrodes[i]]), col="lightblue", lwd=1)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrodes[i]]), col="indianred1", lwd=1)#
		########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=col[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electrodes, ylim=10, legend=T)
electrodes
scalp.cor <-#
function(base, numbers, behaviour=NULL, alpha=0.05,method = c("pearson", "kendall", "spearman"), sig=NULL, envir=.GlobalEnv, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), col="blue", legend=TRUE, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL) {#
#
if (legend.lab=="default"){#
	legend.lab=c(base)#
	}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base,numbers[i1], sep="")),envir=envir)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
#####################
#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], behaviour, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base = le prime lettere degli oggetti #
#numbers= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base, numbers, envir=envir)#
#
categ=list(alldata1)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
	if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=col, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=col#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (!electrodes%in%c("xaxis", "yaxis", "blank", "legend")) {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=col[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrodes[i]]), col="lightblue", lwd=1)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrodes[i]]), col="indianred1", lwd=1)#
		########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=col[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electrodes, ylim=10, legend=T)
warnings()
scalp.cor <-#
function(base, numbers, behaviour=NULL, alpha=0.05,method = c("pearson", "kendall", "spearman"), sig=NULL, envir=.GlobalEnv, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), col="blue", legend=TRUE, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL) {#
#
if (legend.lab=="default"){#
	legend.lab=c(base)#
	}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base,numbers[i1], sep="")),envir=envir)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
#####################
#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], behaviour, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base = le prime lettere degli oggetti #
#numbers= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base, numbers, envir=envir)#
#
categ=list(alldata1)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
	if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=col, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=col#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (!electrodes[i]%in%c("xaxis", "yaxis", "blank", "legend")) {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=col[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrodes[i]]), col="lightblue", lwd=1)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrodes[i]]), col="indianred1", lwd=1)#
		########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=col[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electrodes, ylim=10, legend=T)
elecrodes
electrodes
electrodes[1]="xaxis"
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, behaviour = RT, smo=0, layout=electrodes, ylim=10, legend=T)
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
			if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
RT=rnorm(20, mean=500, sd=200)#
#
scalp.infl("Exp1_word_subj", 1:20, smo=0, layout=electrodes, ylim=10, legend=T)
RT=rnorm(20, mean=500, sd=200)#
#
scalp.infl("Exp1_word_subj", 1:20, smo=0, layout=electrodes, ylim=10)
library(erpR)
for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}
install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", fileinfo=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj", fileinfo=TRUE)#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
 for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
 endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
 format="long")#
		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
 endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
 format="long")#
			datall.long=rbind(datall.long, temp1, temp2)#
	}#
}
head(datall.long)
table(datall.long$condition)
datall.long=NULL
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
 endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
 format="long")#
		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
 endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
 format="long")#
			datall.long=rbind(datall.long, temp1, temp2)#
	}#
}
table(datall.long$condition)
table(datall.long$condition, datall.long$Subject)
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", fileinfo=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj", fileinfo=TRUE)#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
datmidline[,c("Subject", "condition", "electrode")]=factorall(datmidline[,c("Subject", "condition", "electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*electrode+Error(Subject/(condition*electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, electrode="electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, electrode="electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
scalp.t <-#
function(base1, base2, numbers1, numbers2=NULL, paired=TRUE, alpha=0.05, sig=NULL, envir=.GlobalEnv, envir2=NULL, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=c(1,1), lty=c(1,1), color.list=c("blue", "red"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL) {#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
	legend.lab=c(base1, base2)#
}#
#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(numbers2)){#
	numbers2=numbers1}#
#
if (is.null(envir2)){#
	envir2=envir}#
#
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers1)){#
	alldata1.list[[i1]]=eval(parse(file="", text=paste(base1,numbers1[i1], sep="")),envir=envir)#
	}#
for (i2 in 1:length(numbers2)){#
	alldata2.list[[i2]]=eval(parse(file="", text=paste(base2,numbers2[i2], sep="")),envir=envir2)#
	}#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
## creo degli oggetti per stimare il tempo necessario ai calcoli#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
###############
cat("t-test results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		temp2=lapply(alldata2.list, function(x) { element(x,k) } )#
		temp2.1=matrix(unlist(temp2), ncol=length(alldata1.list[[1]]), byrow=TRUE) #di ciascuna riga una #
		#matrice con n righe (una per soggetto) e k colonne (una per elettrodo) #
		alltemp[[k]][[1]]=temp1.1#
		alltemp[[k]][[2]]=temp2.1#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.results.vet[j]=(t.test(alltemp[[k]][[1]][,j], alltemp[[k]][[2]][,j], corr=F, paired=paired)$p.value)<alpha#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER SCALP#
### FUNZIONE PER FARE AVERAGE PER PLOT#
#
#base1 = le prime lettere degli oggetti #
#numbers1= il numero dei soggetti di cui calcolare l'average#
#
alldata1=grandaverage(base=base1, numbers1, envir=envir)#
alldata2=grandaverage(base=base2,numbers2, envir=envir2)#
#
categ=list(alldata1,alldata2)#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
		plot.new()#
		if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
			# plotto le bande di significatività#
			#######################
			abline(v=grep(TRUE,alltemp.results[,electrodes[i]]), col="lightgray")#
			########################
			### NOTA: plotto due volte il grafico: la prima volta con type="n" poi con type="l". Altrimenti le bande si sovrascrivono col grafico#
			lines(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), col=color.list[1],  cex.main=0.85, lwd=lwd[1], lty=lty[1])#
#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
					lines(smooth.spline(categ[[2]][[electrodes[i]]], spar=smo),col=color.list[2], lwd=lwd[2],lty=lty[2])#
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
invisible(alltemp.results)#
}
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)
scalp.infl <-#
function(base, numbers, smo=0, layout=1, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv, t.axis=seq(-100,endmsec,200), scalp.array=NULL, outnumber=1){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
  if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
		for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
		plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]=="xaxis"){#
plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
			if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
scalp.infl
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
library(erpR)
data(ERPsets)
ls()
Exp1_nonwod_subj1
a=list(Exp1_nonword_subj1=Exp1_nonword_subj1, Exp1_nonword_subj2= Exp1_nonword_subj2)
str(a,1)
average.temp=eval(parse(file="", text="Exp1_nonword_subj1",envir=a))
average.temp=eval(parse(file="", text="Exp1_nonword_subj1"),envir=a)
average.temp
average.temp=eval(parse(file="", text="Exp1_nonword_subj1"),envir=NULL)
average.temp
rm(Exp1_nonword_subj1)
ls()
average.temp=eval(parse(file="", text="Exp1_nonword_subj1"),envir=NULL)
average.temp=eval(parse(file="", text="Exp1_nonword_subj1"),envir=a)
average.temp
scalp <-#
function(categ, smo=0.5, layout=1, ylims="auto", yrev=TRUE, startmsec=-200, endmsec=1200, lwd=1, lty=1, color.list=c("blue", "red", "darkgreen"), legend=F, legend.lab="default", t.axis=seq(-100,endmsec,200), scalp.array=NULL){#
#
if (length(legend.lab)==1&legend.lab[1]=="default"){#
legend.lab=deparse(substitute(categ))#
legend.lab=gsub("\\(", "",legend.lab)#
legend.lab=gsub("\\)", "", legend.lab)#
legend.lab=gsub("^list", "", legend.lab)#
legend.lab=gsub(" ", "", legend.lab)#
legend.lab=unlist(strsplit(legend.lab, ","))#
}#
#
if (length(lwd)==1){#
	lwd=rep(lwd, length(categ))}#
if (length(lty)==1){#
	lty=rep(lty, length(categ))}#
#
if (class(categ)!="list"){#
		stop("input object must be a list!!")}#
if (layout[1]==1){#
electrodes=c("yaxis","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
	if (layout[1]==2){#
	electrodes=c("yaxis","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "xaxis", "O1", "OZ", "O2", "blank")#
	}#
		if (layout[1]==3){#
	electrodes=c("yaxis","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "xaxis", "O1", "blank", "O2", "blank")#
	}#
		if (layout[1]==4){#
		electrodes=c("yaxis", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout[1]==5){#
		electrodes=c("yaxis", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}#
	if (length(layout)>1){#
		electrodes=layout#
	}		#
## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
if (ylims=="auto"){#
	## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
	alldata=NULL#
		for (i in 1:length(categ)){#
			alldata=rbind(alldata, categ[[i]])#
		}#
	ymax=max(alldata)#
	ymin=min(alldata)#
	yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
	# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
	yedge=c(-yedge,yedge)#
	}#
if (ylims!="auto"){#
	yedge=ylims#
	yedge=c(-ylims, ylims)#
	}	#
#
if (yrev==TRUE){#
	yedge=sort(yedge, decreasing=T)#
	}#
#
oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
par(mfrow=c(7,5), mai=c(0,0,0,0))#
if (layout[1]==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
if (layout[1]==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
if (!is.null(scalp.array)){#
	par(mfrow=scalp.array, mai=c(0,0,0,0))#
}#
	for (i in 1:(length(electrodes))){#
		if (electrodes[i]=="yaxis"){#
plot(1, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
axis(side=2, pos=dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
	}#
		if (electrodes[i]=="blank") {#
			plot.new()#
		}#
		if (electrodes[i]=="legend"){#
			plot.new()#
			if (legend=="TRUE"){#
	legend("center", legend=legend.lab, col=color.list, cex=1.2, lty=lty, lwd=lwd) #pch=15, pt.bg=color.list#
			}#
		}#
		if (electrodes[i]=="xaxis"){#
plot(1, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
		axis(1, pos=0, at=msectopoints(t.axis, dim(categ[[1]])[1], startmsec, endmsec), labels=paste(t.axis))#
		}#
		if (!electrodes[i]%in%c("xaxis", "yaxis", "legend", "blank")) {#
			plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
#
				totalendmsec=endmsec+abs(startmsec)#
				zeropoint=msectopoints(0, dim(categ[[1]])[1], startmsec=startmsec, endmsec=endmsec)#
				segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
				abline(h=0, lty="longdash")#
				mtext(electrodes[i],side=3, line=-2)#
	if (length(categ)>1&electrodes[i]!="blank") {#
				for (k in 2:length(categ)){#
					lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
					}#
		} #
		}#
	}#
par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
#introduction to R" pag. 68. Vedi anche sotto.#
}
?scalp
word=grandaverage("Exp1_word_subj", 1:20)
scalp(list(word), smo=0, layout=1, ylim=10)
library(tripack)
?tripack
library(akima)
?interp
prime prove scalp map.#
#
source('~/Desktop/pacchetto erpR/prove scalp map/project_3d2d.R', chdir = TRUE)#
#
dat=read.table("~/Desktop/pacchetto erpR/prove scalp map/NN1_whole.forscalpmap.txt", header=T)#
all.elec=read.table("~/Desktop/pacchetto erpR/prove scalp map/elec_1020_124_3dspace_cart.txt")#
all.elec$V1=toupper(all.elec$V1)#
#
elec.names=names(dat)#
#dat.elec.coord=merge(data.frame(elec.names), all.elec, by.x="elec.names", by.y="V1")#
# nota, di alcuni elettrodi non ho le labels, ma credo sia solo legato a un problema di doppia possibilità dei nomi (tipo P5/T8).#
#names(dat.elec.coord)=c("labels","n", "x", "y", "z")#
#
## PROVO CON COORDINATE SFERICHE.#
# prima colonna theta, seconda phi#
dat.elec.coord=read.table("~/Desktop/pacchetto erpR/prove scalp map/ESP_brokencomp.elp")#
names(dat.elec.coord)=c("labels", "theta", "phi")#
#trasformo in coordinate cartesiane.#
#
# trasformo in radianti#
dat.elec.coord$theta=(dat.elec.coord$theta*pi)/180#
dat.elec.coord$phi=(dat.elec.coord$phi*pi)/180#
radius=1#
#
## ho preso le seguenti conversioni da qui http://en.wikipedia.org/wiki/Spherical_coordinate_system#
dat.elec.coord$x=radius*sin(dat.elec.coord$theta)*cos(dat.elec.coord$phi)#
dat.elec.coord$y=radius*sin(dat.elec.coord$theta)*sin(dat.elec.coord$phi)#
dat.elec.coord$z=radius*cos(dat.elec.coord$theta)#
#
write.table(dat.elec.coord[,c("x","y","z")], file="electrodesxyz.txt", row.names=F, col.names=F)#
library(scatterplot3d)#
with(dat.elec.coord, scatterplot3d(x,y,z, xlim=c(-1,1), ylim=c(-1,1), zlim=c(-1,1)))#
#
elec.2d=with(dat.elec.coord, project_3d2d(x,y,z, rep(90,length(x))))#
# per comodità assegno a x e y le x e y calcolare su 2d#
# aggiungo CZ, visto che non c'era nelle coordinate da biosign...#
#elec.2d=rbind(elec.2d, data.frame(x=0, y=0))#
#elec.2d$labels=c(as.character(dat.elec.coord$labels), "CZ")#
elec.2d$labels=as.character(dat.elec.coord$labels)#
#
x=elec.2d$x#
y=elec.2d$y#
## PROVO CHE LA TRASFORMAZIONE ABBIA DATO RISULTATI SENSATI#
with(elec.2d,plot(x,y, type="n"))#
with(elec.2d,text(x,y, labels=labels))#
## PROVO IL GRAFICO#
require (MASS)#
# seleziono solo gli elettrodi di cui ho valori#
dat.sel=dat[,names(dat)%in%elec.2d$labels]#
#
ampl=as.numeric(apply(dat.sel[,],2, mean))#
write.table(ampl, file="Amplitude.txt", row.names=F, col.names=F)#
#
image(kde2d(x,y, ampl, n=20), add=F)#
text(x,y, labels=elec.2d$labels)#
## ho trovato interp in un R-help (ho nel segnalibri)#
library(akima)#
# NOTA: a quanto pare nelle scalp map di matlab viene utilizzata la Delaunay interpolation (l'ho visto guardando i parametri della funzione griddata che viene chiamata#
# dentro topoplot). Esistono pacchetti R che fanno la Delaunay interpolation (tripack, dovrebbe), ma non so se vale la pena.#
# library(kriging) #non funziona, forse troppe poche osservazioni#
#library (sgeostat)#
#
prova.dat=data.frame(x=elec.2d$x, y=elec.2d$y, Ampl=ampl)#
#
#prova.dat.p=point(prova.dat) # non mi ricordo cosa era questo passaggio, ma pare inutile!#
#
#setto un plot.min e un plot.max che userò come margini sia di x che di y per mantenere un cerchio#
plot.min=-1.5#
plot.max=1.5#
#
image(interp(x,y, ampl, xo=seq(min(x), max(x), length = 300), yo=seq(min(y), max(y), length = 300), linear=F, extrap=T),col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5))#
#
# nota per fare sì che si estendesse il risultato molto fuori dall'area degli eletrodi ho cambiato x0 e y0. Ho fatto delle prove, ed effettivamente modificando x0 e y0 l'unica cosa che cambia è l'area di interpolazione. Se infatti fisso gli zlim e faccio due plot affiancati sono identici, cambia solo quanto ho estrapolato i dati lontano dagli elettrodi.#
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 50), yo=seq(plot.min, plot.max, length = 500), linear=F, extrap=T)#
#
interp.xlim.up=which(interp.data$x>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.xlim.inf=which(interp.data$x<(-1.2)) #prendo l'indice del primo valore oltre il limite che imposto. #
#
interp.ylim.up=which(interp.data$y>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.ylim.inf=which(interp.data$y<(-1.2))#
#
interp.data$z[c(interp.xlim.up, interp.xlim.inf),]=NA#
interp.data$z[,c(interp.ylim.up, interp.ylim.inf)]=NA#
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
## creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))#
#
#nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)#
#image(kriging(y,x, ampl), col=heat.colors(7))#
#text(y,x, labels=elec.2d$labels)#
#
# nota che in image, se l'immagine è fuori range viene colorata in bianco. #
# per risolvere prima di plottare l'ampiezza che va fuori range va riportata ad uno degli estremi dei range
prime prove scalp map.#
#
source('~/Desktop/pacchetto erpR/prove scalp map/project_3d2d.R', chdir = TRUE)#
#
dat=read.table("~/Desktop/pacchetto erpR/prove scalp map/NN1_whole.forscalpmap.txt", header=T)#
all.elec=read.table("~/Desktop/pacchetto erpR/prove scalp map/elec_1020_124_3dspace_cart.txt")#
all.elec$V1=toupper(all.elec$V1)#
#
elec.names=names(dat)#
#dat.elec.coord=merge(data.frame(elec.names), all.elec, by.x="elec.names", by.y="V1")#
# nota, di alcuni elettrodi non ho le labels, ma credo sia solo legato a un problema di doppia possibilità dei nomi (tipo P5/T8).#
#names(dat.elec.coord)=c("labels","n", "x", "y", "z")#
#
## PROVO CON COORDINATE SFERICHE.#
# prima colonna theta, seconda phi#
dat.elec.coord=read.table("~/Desktop/pacchetto erpR/prove scalp map/ESP_brokencomp.elp")#
names(dat.elec.coord)=c("labels", "theta", "phi")#
#trasformo in coordinate cartesiane.#
#
# trasformo in radianti#
dat.elec.coord$theta=(dat.elec.coord$theta*pi)/180#
dat.elec.coord$phi=(dat.elec.coord$phi*pi)/180#
radius=1#
#
## ho preso le seguenti conversioni da qui http://en.wikipedia.org/wiki/Spherical_coordinate_system#
dat.elec.coord$x=radius*sin(dat.elec.coord$theta)*cos(dat.elec.coord$phi)#
dat.elec.coord$y=radius*sin(dat.elec.coord$theta)*sin(dat.elec.coord$phi)#
dat.elec.coord$z=radius*cos(dat.elec.coord$theta)#
#
write.table(dat.elec.coord[,c("x","y","z")], file="electrodesxyz.txt", row.names=F, col.names=F)#
library(scatterplot3d)#
with(dat.elec.coord, scatterplot3d(x,y,z, xlim=c(-1,1), ylim=c(-1,1), zlim=c(-1,1)))#
#
elec.2d=with(dat.elec.coord, project_3d2d(x,y,z, rep(90,length(x))))#
# per comodità assegno a x e y le x e y calcolare su 2d#
# aggiungo CZ, visto che non c'era nelle coordinate da biosign...#
#elec.2d=rbind(elec.2d, data.frame(x=0, y=0))#
#elec.2d$labels=c(as.character(dat.elec.coord$labels), "CZ")#
elec.2d$labels=as.character(dat.elec.coord$labels)#
#
x=elec.2d$x#
y=elec.2d$y#
## PROVO CHE LA TRASFORMAZIONE ABBIA DATO RISULTATI SENSATI#
with(elec.2d,plot(x,y, type="n"))#
with(elec.2d,text(x,y, labels=labels))#
## PROVO IL GRAFICO#
require (MASS)#
# seleziono solo gli elettrodi di cui ho valori#
dat.sel=dat[,names(dat)%in%elec.2d$labels]#
#
ampl=as.numeric(apply(dat.sel[,],2, mean))#
write.table(ampl, file="Amplitude.txt", row.names=F, col.names=F)#
#
image(kde2d(x,y, ampl, n=20), add=F)#
text(x,y, labels=elec.2d$labels)#
## ho trovato interp in un R-help (ho nel segnalibri)#
library(akima)#
# NOTA: a quanto pare nelle scalp map di matlab viene utilizzata la Delaunay interpolation (l'ho visto guardando i parametri della funzione griddata che viene chiamata#
# dentro topoplot). Esistono pacchetti R che fanno la Delaunay interpolation (tripack, dovrebbe), ma non so se vale la pena.#
# library(kriging) #non funziona, forse troppe poche osservazioni#
#library (sgeostat)#
#
prova.dat=data.frame(x=elec.2d$x, y=elec.2d$y, Ampl=ampl)#
#
#prova.dat.p=point(prova.dat) # non mi ricordo cosa era questo passaggio, ma pare inutile!#
#
#setto un plot.min e un plot.max che userò come margini sia di x che di y per mantenere un cerchio#
plot.min=-1.5#
plot.max=1.5#
#
image(interp(x,y, ampl, xo=seq(min(x), max(x), length = 300), yo=seq(min(y), max(y), length = 300), linear=F, extrap=T),col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5))#
#
# nota per fare sì che si estendesse il risultato molto fuori dall'area degli eletrodi ho cambiato x0 e y0. Ho fatto delle prove, ed effettivamente modificando x0 e y0 l'unica cosa che cambia è l'area di interpolazione. Se infatti fisso gli zlim e faccio due plot affiancati sono identici, cambia solo quanto ho estrapolato i dati lontano dagli elettrodi.#
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 400), yo=seq(plot.min, plot.max, length = 400), linear=F, extrap=T)#
#
interp.xlim.up=which(interp.data$x>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.xlim.inf=which(interp.data$x<(-1.2)) #prendo l'indice del primo valore oltre il limite che imposto. #
#
interp.ylim.up=which(interp.data$y>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.ylim.inf=which(interp.data$y<(-1.2))#
#
interp.data$z[c(interp.xlim.up, interp.xlim.inf),]=NA#
interp.data$z[,c(interp.ylim.up, interp.ylim.inf)]=NA#
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
## creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))#
#
#nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)#
#image(kriging(y,x, ampl), col=heat.colors(7))#
#text(y,x, labels=elec.2d$labels)#
#
# nota che in image, se l'immagine è fuori range viene colorata in bianco. #
# per risolvere prima di plottare l'ampiezza che va fuori range va riportata ad uno degli estremi dei range
prime prove scalp map.#
#
source('~/Desktop/pacchetto erpR/prove scalp map/project_3d2d.R', chdir = TRUE)#
#
dat=read.table("~/Desktop/pacchetto erpR/prove scalp map/NN1_whole.forscalpmap.txt", header=T)#
all.elec=read.table("~/Desktop/pacchetto erpR/prove scalp map/elec_1020_124_3dspace_cart.txt")#
all.elec$V1=toupper(all.elec$V1)#
#
elec.names=names(dat)#
#dat.elec.coord=merge(data.frame(elec.names), all.elec, by.x="elec.names", by.y="V1")#
# nota, di alcuni elettrodi non ho le labels, ma credo sia solo legato a un problema di doppia possibilità dei nomi (tipo P5/T8).#
#names(dat.elec.coord)=c("labels","n", "x", "y", "z")#
#
## PROVO CON COORDINATE SFERICHE.#
# prima colonna theta, seconda phi#
dat.elec.coord=read.table("~/Desktop/pacchetto erpR/prove scalp map/ESP_brokencomp.elp")#
names(dat.elec.coord)=c("labels", "theta", "phi")#
#trasformo in coordinate cartesiane.#
#
# trasformo in radianti#
dat.elec.coord$theta=(dat.elec.coord$theta*pi)/180#
dat.elec.coord$phi=(dat.elec.coord$phi*pi)/180#
radius=1#
#
## ho preso le seguenti conversioni da qui http://en.wikipedia.org/wiki/Spherical_coordinate_system#
dat.elec.coord$x=radius*sin(dat.elec.coord$theta)*cos(dat.elec.coord$phi)#
dat.elec.coord$y=radius*sin(dat.elec.coord$theta)*sin(dat.elec.coord$phi)#
dat.elec.coord$z=radius*cos(dat.elec.coord$theta)#
#
write.table(dat.elec.coord[,c("x","y","z")], file="electrodesxyz.txt", row.names=F, col.names=F)#
library(scatterplot3d)#
with(dat.elec.coord, scatterplot3d(x,y,z, xlim=c(-1,1), ylim=c(-1,1), zlim=c(-1,1)))#
#
elec.2d=with(dat.elec.coord, project_3d2d(x,y,z, rep(90,length(x))))#
# per comodità assegno a x e y le x e y calcolare su 2d#
# aggiungo CZ, visto che non c'era nelle coordinate da biosign...#
#elec.2d=rbind(elec.2d, data.frame(x=0, y=0))#
#elec.2d$labels=c(as.character(dat.elec.coord$labels), "CZ")#
elec.2d$labels=as.character(dat.elec.coord$labels)#
#
x=elec.2d$x#
y=elec.2d$y#
## PROVO CHE LA TRASFORMAZIONE ABBIA DATO RISULTATI SENSATI#
with(elec.2d,plot(x,y, type="n"))#
with(elec.2d,text(x,y, labels=labels))#
## PROVO IL GRAFICO#
require (MASS)#
# seleziono solo gli elettrodi di cui ho valori#
dat.sel=dat[,names(dat)%in%elec.2d$labels]#
#
ampl=as.numeric(apply(dat.sel[,],2, mean))#
write.table(ampl, file="Amplitude.txt", row.names=F, col.names=F)#
#
image(kde2d(x,y, ampl, n=20), add=F)#
text(x,y, labels=elec.2d$labels)#
## ho trovato interp in un R-help (ho nel segnalibri)#
library(akima)#
# NOTA: a quanto pare nelle scalp map di matlab viene utilizzata la Delaunay interpolation (l'ho visto guardando i parametri della funzione griddata che viene chiamata#
# dentro topoplot). Esistono pacchetti R che fanno la Delaunay interpolation (tripack, dovrebbe), ma non so se vale la pena.#
# library(kriging) #non funziona, forse troppe poche osservazioni#
#library (sgeostat)#
#
prova.dat=data.frame(x=elec.2d$x, y=elec.2d$y, Ampl=ampl)#
#
#prova.dat.p=point(prova.dat) # non mi ricordo cosa era questo passaggio, ma pare inutile!#
#
#setto un plot.min e un plot.max che userò come margini sia di x che di y per mantenere un cerchio#
plot.min=-1.5#
plot.max=1.5#
#
image(interp(x,y, ampl, xo=seq(min(x), max(x), length = 300), yo=seq(min(y), max(y), length = 300), linear=F, extrap=T),col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5))#
#
# nota per fare sì che si estendesse il risultato molto fuori dall'area degli eletrodi ho cambiato x0 e y0. Ho fatto delle prove, ed effettivamente modificando x0 e y0 l'unica cosa che cambia è l'area di interpolazione. Se infatti fisso gli zlim e faccio due plot affiancati sono identici, cambia solo quanto ho estrapolato i dati lontano dagli elettrodi.#
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 1000), yo=seq(plot.min, plot.max, length = 1000), linear=F, extrap=T)#
#
interp.xlim.up=which(interp.data$x>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.xlim.inf=which(interp.data$x<(-1.2)) #prendo l'indice del primo valore oltre il limite che imposto. #
#
interp.ylim.up=which(interp.data$y>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.ylim.inf=which(interp.data$y<(-1.2))#
#
interp.data$z[c(interp.xlim.up, interp.xlim.inf),]=NA#
interp.data$z[,c(interp.ylim.up, interp.ylim.inf)]=NA#
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
## creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))#
#
#nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)#
#image(kriging(y,x, ampl), col=heat.colors(7))#
#text(y,x, labels=elec.2d$labels)#
#
# nota che in image, se l'immagine è fuori range viene colorata in bianco. #
# per risolvere prima di plottare l'ampiezza che va fuori range va riportata ad uno degli estremi dei range
contour(interp.data)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE)
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE)
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))
nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
image(interp.data, col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
image(interp.data, col=heat.colors(10), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
image(interp.data, col=heat.colors(20), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
image(interp.data, col=heat.colors(20), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 50), yo=seq(plot.min, plot.max, length = 50), linear=F, extrap=T)
image(interp.data, col=heat.colors(20), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 100), yo=seq(plot.min, plot.max, length = 100), linear=F, extrap=T)
image(interp.data, col=heat.colors(20), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
?image
filled.contour(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
filled.contour(interp.data, col=rainbow(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
?image
require(grDevices) # for colours#
x <- -6:16#
op <- par(mfrow = c(2, 2))#
contour(outer(x, x), method = "edge", vfont = c("sans serif", "plain"))#
z <- outer(x, sqrt(abs(x)), FUN = "/")#
image(x, x, z)#
contour(x, x, z, col = "pink", add = TRUE, method = "edge",#
        vfont = c("sans serif", "plain"))#
contour(x, x, z, ylim = c(1, 6), method = "simple", labcex = 1)#
contour(x, x, z, ylim = c(-6, 6), nlev = 20, lty = 2, method = "simple")#
par(op)
Persian Rug Art:#
x <- y <- seq(-4*pi, 4*pi, len = 27)#
r <- sqrt(outer(x^2, y^2, "+"))#
opar <- par(mfrow = c(2, 2), mar = rep(0, 4))#
for(f in pi^(0:3))#
  contour(cos(r^2)*exp(-r/f),#
          drawlabels = FALSE, axes = FALSE, frame = TRUE)#
#
rx <- range(x <- 10*1:nrow(volcano))#
ry <- range(y <- 10*1:ncol(volcano))#
ry <- ry + c(-1, 1) * (diff(rx) - diff(ry))/2#
tcol <- terrain.colors(12)#
par(opar); opar <- par(pty = "s", bg = "lightcyan")#
plot(x = 0, y = 0, type = "n", xlim = rx, ylim = ry, xlab = "", ylab = "")#
u <- par("usr")#
rect(u[1], u[3], u[2], u[4], col = tcol[8], border = "red")#
contour(x, y, volcano, col = tcol[2], lty = "solid", add = TRUE,#
        vfont = c("sans serif", "plain"))#
title("A Topographic Map of Maunga Whau", font = 4)#
abline(h = 200*0:4, v = 200*0:4, col = "lightgray", lty = 2, lwd = 0.1)
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
filled.contour(x, y, volcano, color = terrain.colors,#
    plot.title = title(main = "The Topography of Maunga Whau",#
    xlab = "Meters North", ylab = "Meters West"),#
    plot.axes = { axis(1, seq(100, 800, by = 100))#
                  axis(2, seq(100, 600, by = 100)) },#
    key.title = title(main = "Height\n(meters)"),#
    key.axes = axis(4, seq(90, 190, by = 10)))
filled.contour(x, y, volcano, color = terrain.colors,#
    plot.title = title(main = "The Topography of Maunga Whau",#
    xlab = "Meters North", ylab = "Meters West"),#
    plot.axes = { axis(1, seq(100, 800, by = 100))#
                  axis(2, seq(100, 600, by = 100)) },#
    key.title = title(main = "Height\n(meters)"),#
    key.axes = axis(4, seq(90, 190, by = 10)))
ersian Rug Art:#
x <- y <- seq(-4*pi, 4*pi, len = 27)#
r <- sqrt(outer(x^2, y^2, "+"))#
filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE)#
## rather, the key *should* be labeled:#
filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE,#
               plot.axes = {})
?rainbow
filled.contour(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)
prime prove scalp map.#
#
source('~/Desktop/pacchetto erpR/prove scalp map/project_3d2d.R', chdir = TRUE)#
#
dat=read.table("~/Desktop/pacchetto erpR/prove scalp map/NN1_whole.forscalpmap.txt", header=T)#
all.elec=read.table("~/Desktop/pacchetto erpR/prove scalp map/elec_1020_124_3dspace_cart.txt")#
all.elec$V1=toupper(all.elec$V1)#
#
elec.names=names(dat)#
#dat.elec.coord=merge(data.frame(elec.names), all.elec, by.x="elec.names", by.y="V1")#
# nota, di alcuni elettrodi non ho le labels, ma credo sia solo legato a un problema di doppia possibilità dei nomi (tipo P5/T8).#
#names(dat.elec.coord)=c("labels","n", "x", "y", "z")#
#
## PROVO CON COORDINATE SFERICHE.#
# prima colonna theta, seconda phi#
dat.elec.coord=read.table("~/Desktop/pacchetto erpR/prove scalp map/ESP_brokencomp.elp")#
names(dat.elec.coord)=c("labels", "theta", "phi")#
#trasformo in coordinate cartesiane.#
#
# trasformo in radianti#
dat.elec.coord$theta=(dat.elec.coord$theta*pi)/180#
dat.elec.coord$phi=(dat.elec.coord$phi*pi)/180#
radius=1#
#
## ho preso le seguenti conversioni da qui http://en.wikipedia.org/wiki/Spherical_coordinate_system#
dat.elec.coord$x=radius*sin(dat.elec.coord$theta)*cos(dat.elec.coord$phi)#
dat.elec.coord$y=radius*sin(dat.elec.coord$theta)*sin(dat.elec.coord$phi)#
dat.elec.coord$z=radius*cos(dat.elec.coord$theta)#
#
write.table(dat.elec.coord[,c("x","y","z")], file="electrodesxyz.txt", row.names=F, col.names=F)#
library(scatterplot3d)#
with(dat.elec.coord, scatterplot3d(x,y,z, xlim=c(-1,1), ylim=c(-1,1), zlim=c(-1,1)))#
#
elec.2d=with(dat.elec.coord, project_3d2d(x,y,z, rep(90,length(x))))#
# per comodità assegno a x e y le x e y calcolare su 2d#
# aggiungo CZ, visto che non c'era nelle coordinate da biosign...#
#elec.2d=rbind(elec.2d, data.frame(x=0, y=0))#
#elec.2d$labels=c(as.character(dat.elec.coord$labels), "CZ")#
elec.2d$labels=as.character(dat.elec.coord$labels)#
#
x=elec.2d$x#
y=elec.2d$y#
## PROVO CHE LA TRASFORMAZIONE ABBIA DATO RISULTATI SENSATI#
with(elec.2d,plot(x,y, type="n"))#
with(elec.2d,text(x,y, labels=labels))#
## PROVO IL GRAFICO#
require (MASS)#
# seleziono solo gli elettrodi di cui ho valori#
dat.sel=dat[,names(dat)%in%elec.2d$labels]#
#
ampl=as.numeric(apply(dat.sel[,],2, mean))#
write.table(ampl, file="Amplitude.txt", row.names=F, col.names=F)#
#
image(kde2d(x,y, ampl, n=20), add=F)#
text(x,y, labels=elec.2d$labels)#
## ho trovato interp in un R-help (ho nel segnalibri)#
library(akima)#
# NOTA: a quanto pare nelle scalp map di matlab viene utilizzata un metodo interno di matlab (v4) (l'ho visto guardando i parametri della funzione griddata che viene chiamata#
# dentro topoplot). Esistono pacchetti R che fanno la Delaunay interpolation (tripack, dovrebbe), ma non so se vale la pena.#
#   [Xi,Yi,Zi] = griddata(inty,intx,double(intValues),yi',xi,'v4'); % interpolate data#
# puoi trovare info su matlab cercando interpolate nel file topoplot.m#
#
# library(kriging) #non funziona, forse troppe poche osservazioni#
#library (sgeostat)#
#
prova.dat=data.frame(x=elec.2d$x, y=elec.2d$y, Ampl=ampl)#
#
#prova.dat.p=point(prova.dat) # non mi ricordo cosa era questo passaggio, ma pare inutile!#
#
#setto un plot.min e un plot.max che userò come margini sia di x che di y per mantenere un cerchio#
plot.min=-1.5#
plot.max=1.5#
#
image(interp(x,y, ampl, xo=seq(min(x), max(x), length = 300), yo=seq(min(y), max(y), length = 300), linear=F, extrap=T),col=heat.colors(7), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5))#
#
# nota per fare sì che si estendesse il risultato molto fuori dall'area degli eletrodi ho cambiato x0 e y0. Ho fatto delle prove, ed effettivamente modificando x0 e y0 l'unica cosa che cambia è l'area di interpolazione. Se infatti fisso gli zlim e faccio due plot affiancati sono identici, cambia solo quanto ho estrapolato i dati lontano dagli elettrodi.#
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
#contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))#
#
#nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)#
#image(kriging(y,x, ampl), col=heat.colors(7))#
#text(y,x, labels=elec.2d$labels)
nota per fare sì che si estendesse il risultato molto fuori dall'area degli eletrodi ho cambiato x0 e y0. Ho fatto delle prove, ed effettivamente modificando x0 e y0 l'unica cosa che cambia è l'area di interpolazione. Se infatti fisso gli zlim e faccio due plot affiancati sono identici, cambia solo quanto ho estrapolato i dati lontano dagli elettrodi.#
interp.data=interp(x,y, ampl, xo=seq(plot.min, plot.max, length = 300), yo=seq(plot.min, plot.max, length = 300), linear=F, extrap=T)#
#
interp.xlim.up=which(interp.data$x>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.xlim.inf=which(interp.data$x<(-1.2)) #prendo l'indice del primo valore oltre il limite che imposto. #
#
interp.ylim.up=which(interp.data$y>1.2) #prendo l'indice del primo valore oltre il limite che imposto#
interp.ylim.inf=which(interp.data$y<(-1.2))#
#
interp.data$z[c(interp.xlim.up, interp.xlim.inf),]=NA#
interp.data$z[,c(interp.ylim.up, interp.ylim.inf)]=NA#
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
#contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)#
## creo il cerchio#
library(plotrix)#
circ.coord=draw.circle(0,0, 1)#
#prendo la y della x più esterna#
lim.sx=which(circ.coord$x==min(circ.coord$x))#
lim.dx=which(circ.coord$x==max(circ.coord$x))#
#
#nota il grafico è costruito da dx verso sx, perchè i punti in circ.coord sono ordinati da 1 a -1 come x.#
pol.x=c(plot.max, circ.coord$x[lim.dx:lim.sx], plot.min, plot.min, plot.max, plot.max)#
pol.y=c(0.2, -circ.coord$y[lim.sx:lim.dx], 0.2, plot.min, plot.min, 0.2)#
# nota che metto -0.2, ma sarebbe 0. non metto esattamente 0, perché altrimenti le due metà della maschera si sfiorano e rimane una piccola riga colorata.#
#
polygon(pol.x, pol.y, col="white", lty="blank")#
polygon(pol.x, -pol.y, col="white", lty="blank")#
#
points(x,y, pch=19, col="black")#
text(x,y+0.1, labels=elec.2d$labels)
?contour
interp.data
?image
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=10)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=11)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=16)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=1)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=20)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, breaks=30)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
?contour
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, method="edge")
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, method="simple")
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, method="flattest")
?contour
?image
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F)
cont_levels=seq(-5,5, (10/15))
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, levels=cont_levels)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
#
cont_levels=seq(-5,5, (10/15))#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, levels=cont_levels)
image(interp.data, col=heat.colors(15), xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F)#
#
cont_levels=seq(-5,5, (10/15))#
contour(interp.data, xlim=c(plot.min, plot.max), ylim=c(plot.min, plot.max), zlim=c(-5, 5), frame.plot=F, axes=F, add=TRUE, drawlabels=F, levels=cont_levels)
image(kriging(y,x, ampl), col=heat.colors(7))
library(kriging) #non funziona, forse troppe poche osservazioni
library(kriging) #non funziona, forse troppe poche osservazioni
image(kriging(y,x, ampl), col=heat.colors(7))
image(kriging(x,y, ampl), col=heat.colors(7))
?kriging
image(kriging(x,y, ampl), col=heat.colors(7), model="gaussian")
Krige and create the map#
kriged <- kriging(x, y, z, polygons=p, pixels=300)#
image(kriged, xlim = extendrange(x), ylim = extendrange(y))
Krige random data for a specified area using a list of polygons#
library(maps)#
usa <- map("usa", "main", plot = FALSE)#
p <- list(data.frame(usa$x, usa$y))#
#
# Create some random data#
x <- runif(50, min(p[[1]][,1]), max(p[[1]][,1]))#
y <- runif(50, min(p[[1]][,2]), max(p[[1]][,2]))#
z <- rnorm(50)#
#
# Krige and create the map#
kriged <- kriging(x, y, z, polygons=p, pixels=300)#
image(kriged, xlim = extendrange(x), ylim = extendrange(y))
