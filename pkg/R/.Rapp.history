res
hist(res, xlim=c(-0.0005, 0.0005))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred0= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}
predman(panel1dat)
panel1dat
attach(panel1dat)
mypred0= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)
mypred0
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}
predman(panel1dat)
detach(panel1dat)
predman(panel1dat)
panel1dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])
pred_panel2dat=predman(panel2dat)
detach(panel1dat)
pred_panel2dat=predman(panel2dat)
pred_panel2dat
detach(panel2dat)
pred_panel3dat=predman(panel3dat)
pred_panel3dat
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) #ho creato lo step in modo da creare passi uguali. Ma non influenzerà visto che verrà fatta una retta.#
par(mfrow=c(3,1))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
panel1dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=exp(pred_panel2dat)#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=exp(pred_panel3dat)#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) #ho creato lo step in modo da creare passi uguali. Ma non influenzerà visto che verrà fatta una retta.#
par(mfrow=c(3,1))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=exp(pred_panel2dat)#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=exp(pred_panel3dat)#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])
panel1dat
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) #ho creato lo step in modo da creare passi uguali. Ma non influenzerà visto che verrà fatta una retta.#
par(mfrow=c(3,2))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=exp(pred_panel2dat)#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=exp(pred_panel3dat)#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=exp(pred_panel5dat)#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=exp(pred_panel6dat)#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) #ho creato lo step in modo da creare passi uguali. Ma non influenzerà visto che verrà fatta una retta.#
par(mfrow=c(3,2))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=exp(pred_panel2dat)#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=exp(pred_panel5dat)#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=exp(pred_panel3dat)#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=exp(pred_panel6dat)#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
carico gli oggetti necessari riferendomi ad un altro script.#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
model_pred=predict(NN.final.reported)#
#
#creo un vettore vuoto.#
res=NULL#
#
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
for (i in 1:length(model_pred)) {#
#
#recupero l'osservazione i-esima del modello. Nota che lo faccio dal modello perché alcune osservazioni sono state escluse dal data.frame originale.#
realdat=NN.final.reported@frame[i,]#
#
#creo la variabile typeNNsx come 0 se NNdx e 1 se NNsx.#
realdat$typeNNsx=as.numeric(realdat$type=="NNsx")#
attach(realdat)#
#
#calcolo manualmente il modello.#
mypred0= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5]* res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21]* typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
#
detach(realdat)#
#
# creo gli effetti random #
ranSubj=ranef(NN.final.reported)$Subject[rownames(ranef(NN.final.reported)$Subject)%in%realdat$Subject,]#
ranItem=ranef(NN.final.reported)$TARGET[rownames(ranef(NN.final.reported)$TARGET)%in%realdat$TARGET,]#
#
# li aggiungo alla previsione#
mypred=mypred0+ranSubj+ranItem#
#
#calcolo la differenza tra il modello e la mia previsione#
res[i]=mypred-model_pred[i]#
#
}#
#corrispondono praticamente in maniera perfetta, probabilmente ci sono solo errori di approssimazione#
#
hist(res, xlim=c(-0.0005, 0.0005))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) #ho creato lo step in modo da creare passi uguali. Ma non influenzerà visto che verrà fatta una retta.#
par(mfrow=c(3,2))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=exp(pred_panel2dat)#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=exp(pred_panel5dat)#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 12")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=exp(pred_panel3dat)#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=exp(pred_panel6dat)#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 14")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
m <- matrix(c(1,2,3,3,4,5,6,6),ncol = 2,byrow = TRUE)#
layout(m,widths = c(0.5,0.5),heights = c(0.45,0.05,0.45,0.05))#
#
par(mar = c(2,4,4,2) + 0.1)#
hist(x1, xlab="", main="Group A")#
hist(x2, xlab="", main="Group B")#
#
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)#
#
par(mar = c(2,4,2,2) + 0.1)#
hist(x3, xlab="", main="")#
hist(x4, xlab="", main="")#
#
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)
x1 = rnorm(100)#
x2 = rnorm(100)#
x3 = rnorm(100)#
x4 = rnorm(100)#
#
par(mfrow=c(2,2)) #
hist(x1, xlab="", main="Group A")#
hist(x2, xlab="", main="Group B")#
hist(x3, xlab="", main="")#
hist(x4, xlab="", main="")
m <- matrix(c(1,2,3,3,4,5,6,6),ncol = 2,byrow = TRUE)#
layout(m,widths = c(0.5,0.5),heights = c(0.45,0.05,0.45,0.05))#
#
par(mar = c(2,4,4,2) + 0.1)#
hist(x1, xlab="", main="Group A")#
hist(x2, xlab="", main="Group B")#
#
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)#
#
par(mar = c(2,4,2,2) + 0.1)#
hist(x3, xlab="", main="")#
hist(x4, xlab="", main="")#
#
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)
m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)
par(mar = c(2,4,4,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])
SUDDIVIDO I PANNELLI#
m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
layout(m,widths = c(0.5,0.5),heights = c(0.45,0.05,0.45,0.05))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)#
par(mar = c(2,4,4,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])
m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
layout(m)#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)
u[4]
SUDDIVIDO I PANNELLI#
m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
layout(m)#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Here",col = "red",pos = 1)#
par(mar = c(2,4,4,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])
SUDDIVIDO I PANNELLI#
m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
layout(m)#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
par(mar = c(0,0,0,0)) #
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
u <- par("usr")#
text(1,u[4],labels = "Length = 10", pos = 1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel1dat)#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=12) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
attach(panel4dat)#
#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=exp(pred_panel4dat)#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="Compound length = 10")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) ##
#############################################
### SUDDIVIDO I PANNELLI#
#############################################
#
#m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
#layout(m,widths = c(0.5,0.5),heights = c(0.04, 0.3, 0.03, 0.3, 0.03, 0.3))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
###############
# LABEL LENGTH = 10#
##############
#oldpar=par()#
#
#par(mar=c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 10", pos = 1, cex=1.5)#
##########
#
par(mfrow=c(3,2), mar=c(5.1, 4.1, 2, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=pred_panel1dat#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="", yaxt="n")#
axis(2, at=log(seq(100, 2000, 300)), labels=seq(100, 2000, 300))#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=10) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=pred_panel4dat#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 10#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 12", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=pred_panel2dat#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=pred_panel5dat#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 14#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 14", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=pred_panel3dat#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=pred_panel6dat#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 7.2984451) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
max(stimuliNN$log_freq_repub)
max(stimuliNN$log_freq.target.repub)
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) ##
#############################################
### SUDDIVIDO I PANNELLI#
#############################################
#
#m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
#layout(m,widths = c(0.5,0.5),heights = c(0.04, 0.3, 0.03, 0.3, 0.03, 0.3))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
###############
# LABEL LENGTH = 10#
##############
#oldpar=par()#
#
#par(mar=c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 10", pos = 1, cex=1.5)#
##########
#
par(mfrow=c(3,2), mar=c(5.1, 4.1, 2, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=pred_panel1dat#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(5,8), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="", yaxt="n")#
axis(2, at=log(seq(100, 2000, 300)), labels=seq(100, 2000, 300))#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=10) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=pred_panel4dat#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 10#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 12", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=pred_panel2dat#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=pred_panel5dat#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 14#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 14", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=pred_panel3dat#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=pred_panel6dat#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 7.2984451) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 6.8) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 6) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 7.2984451) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0,7.5), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 7.2984451) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) ##
#############################################
### SUDDIVIDO I PANNELLI#
#############################################
#
#m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
#layout(m,widths = c(0.5,0.5),heights = c(0.04, 0.3, 0.03, 0.3, 0.03, 0.3))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
###############
# LABEL LENGTH = 10#
##############
#oldpar=par()#
#
#par(mar=c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 10", pos = 1, cex=1.5)#
##########
#
par(mfrow=c(3,2), mar=c(5.1, 4.1, 2, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=pred_panel1dat#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(5,8), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="", yaxt="n")#
axis(2, at=log(seq(100, 2000, 300)), labels=seq(100, 2000, 300))#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=10) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=pred_panel4dat#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 10#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 12", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=pred_panel2dat#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=pred_panel5dat#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 14#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 14", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=pred_panel3dat#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=pred_panel6dat#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
par(mfrow=c(1,2))#
### interazione type*freq.const1*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_length.target=c(8,14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=median(stimuliNN$log_freq.target.repub) ##
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, 10), length.target=rep(panels_length.target, 5), log_freq.target.repub=rep(panels_comp.freq, 10))#
#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=pred_panel1dat#
plot(panel1dat$length.target, panel1dat$dep, type="n", ylim=c(5, 8), xlim=c(8,15), ylab="Total View Duration", xlab="Compound length", main="NN1")#
segments(panel1dat[1,]$length.target, panel1dat[1,]$dep, panel1dat[2,]$length.target, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$length.target, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$length.target, panel1dat[3,]$dep, panel1dat[4,]$length.target, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$length.target, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$length.target, panel1dat[5,]$dep, panel1dat[6,]$length.target, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$length.target, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$length.target, panel1dat[7,]$dep, panel1dat[8,]$length.target, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$length.target, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$length.target, panel1dat[9,]$dep, panel1dat[10,]$length.target, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$length.target, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, 10), length.target=rep(panels_length.target, 5), log_freq.target.repub=rep(panels_comp.freq, 10))#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=pred_panel2dat#
plot(panel2dat$length.target, panel2dat$dep, type="n", ylim=c(5, 8), xlim=c(8,15), ylab="Total View Duration", xlab="Compound length", main="NN2")#
segments(panel2dat[1,]$length.target, panel2dat[1,]$dep, panel2dat[2,]$length.target, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$length.target, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$length.target, panel2dat[3,]$dep, panel2dat[4,]$length.target, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$length.target, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$length.target, panel2dat[5,]$dep, panel2dat[6,]$length.target, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$length.target, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$length.target, panel2dat[7,]$dep, panel2dat[8,]$length.target, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$length.target, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$length.target, panel2dat[9,]$dep, panel2dat[10,]$length.target, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$length.target, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
#
# TYPE * FREQ.COMP * FREQ1#
#
panels_freq.const2=median(stimuliNN$res_log_freq.const2.repub)#
panels_length.target=median(stimuliNN$length.target)#
panels_comp.freq=c(0.6931472, 7.2984451) #
panels_freq.const1=quantile(stimuliNN$log_freq.const1.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=exp(pred_panel1dat)#
#
par(mfrow=c(1,2))#
#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN1")#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[2],2))#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[4],2))#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[6],2))#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[8],2))#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=round(panel1dat$log_freq.const1.repub[10],2))#
panel2dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(panels_freq.const1, each=2), res_log_freq.const2.repub=rep(panels_freq.const2, each=5), length.target=rep(panels_length.target, 10), log_freq.target.repub=rep(panels_comp.freq, 5))#
#
pred_panel2dat=predman(panel2dat)#
panel2dat$dep=exp(pred_panel2dat)#
#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(200, 2000), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="NN2")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[2],2))#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[4],2))#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[6],2))#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[8],2))#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=round(panel2dat$log_freq.const1.repub[10],2))
prima manda script analisi trasparenza#
source('~/Desktop/eye mvm compounds/composti rating trasparenza/history analisi frasi con trasparenza.R', chdir = TRUE)#
###### FIGURA 2 PAPER #######
coeffs=summary(NN.final.reported)$coefficients[,"Estimate"]#
#creo funzione per fare previsioni#
#
predman<-function(dat) {#
attach(dat)#
mypred= #
coeffs[1] + #
(typeNNsx*coeffs[2]) +  #
(coeffs[3] * log_freq.target.repub  )+ #
(coeffs[4] * log_freq.const1.repub )+ #
(coeffs[5] * res_log_freq.const2.repub )+#
(coeffs[6] * length.target) + #
(coeffs[7] * typeNNsx*log_freq.target.repub)+ #
(coeffs[8] * typeNNsx*log_freq.const1.repub )+ #
(coeffs[9] * log_freq.target.repub * log_freq.const1.repub )+#
(coeffs[10] * typeNNsx * res_log_freq.const2.repub  )+ #
(coeffs[11] * log_freq.target.repub * res_log_freq.const2.repub )+ #
(coeffs[12] * typeNNsx * length.target )+#
(coeffs[13] * log_freq.target.repub * length.target ) + #
(coeffs[14] * log_freq.const1.repub*length.target ) + #
(coeffs[15] * res_log_freq.const2.repub*length.target) + #
(coeffs[16] * typeNNsx*log_freq.target.repub*log_freq.const1.repub )+#
(coeffs[17] * typeNNsx * log_freq.target.repub * res_log_freq.const2.repub) +#
(coeffs[18] * typeNNsx * log_freq.target.repub * length.target) +#
(coeffs[19] * typeNNsx*log_freq.const1.repub*length.target)+#
(coeffs[20] * log_freq.target.repub*log_freq.const1.repub*length.target) + #
(coeffs[21] * typeNNsx * res_log_freq.const2.repub * length.target)+#
(coeffs[22] * log_freq.target.repub*res_log_freq.const2.repub*length.target) + #
(coeffs[23] * typeNNsx*log_freq.target.repub*res_log_freq.const2.repub*length.target)#
detach(dat)#
#
return(mypred)#
}#
### interazione type*freq.comp*freq2*length#
#
#pannello 1 type=NN1; freq.comp=span, freq.const2=5 values, length=3 values#
#
panels_freq.const2=quantile(stimuliNN$res_log_freq.const2.repub, prob=c(0.10, 0.30, 0.50, 0.70, 0.80), type=1) #
# i valori che mi trova con i quantili potrebbero non essere osservati, cambio metodo di definizione di quantili (di default type=7) per ottenere valori osservati#
panels_or_freq.const2= stimuliNN[stimuliNN$res_log_freq.const2.repub%in%panels_freq.const2, "log_freq.const2.repub"]#
panels_or_freq.const2=sort(round(panels_or_freq.const2,2))#
# recupero i valori grezzi di frequenza assoluta associata ai residui.#
#
panels_length.target=c(10, 12, 14) #
#in realtà usando i quantili 0.20, 0.40 e 0.60 i valori sarebbero troppo simili, per cui li ho presi io arbitariamente con un range decente.#
panels_comp.freq=c(0.6931472, 7.2984451) ##
#############################################
### SUDDIVIDO I PANNELLI#
#############################################
#
#m <- matrix(c(1,1,2,3,4,4,5,6,7,7,8,9),ncol = 2,byrow = TRUE)#
#layout(m,widths = c(0.5,0.5),heights = c(0.04, 0.3, 0.03, 0.3, 0.03, 0.3))#
#############################################
######## PANEL 1  (LENGTH=10) ###############
#############################################
###############
# LABEL LENGTH = 10#
##############
#oldpar=par()#
#
#par(mar=c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 10", pos = 1, cex=1.5)#
##########
#
par(mfrow=c(3,2), mar=c(5.1, 4.1, 2, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
panel1dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel1dat=predman(panel1dat)#
#
panel1dat$dep=pred_panel1dat#
plot(panel1dat$log_freq.target.repub, panel1dat$dep, type="n", ylim=c(5,8), xlim=c(0, 8), ylab="Total View Duration", xlab="Compound frequency", main="", yaxt="n")#
axis(2, at=log(seq(100, 2000, 300)), labels=seq(100, 2000, 300))#
segments(panel1dat[1,]$log_freq.target.repub, panel1dat[1,]$dep, panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, lty=1) #
text(panel1dat[2,]$log_freq.target.repub, panel1dat[2,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[2])#
segments(panel1dat[3,]$log_freq.target.repub, panel1dat[3,]$dep, panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, lty=2)#
text(panel1dat[4,]$log_freq.target.repub, panel1dat[4,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[4])#
segments(panel1dat[5,]$log_freq.target.repub, panel1dat[5,]$dep, panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, lty=3)#
text(panel1dat[6,]$log_freq.target.repub, panel1dat[6,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[6])#
segments(panel1dat[7,]$log_freq.target.repub, panel1dat[7,]$dep, panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, lty=3)#
text(panel1dat[8,]$log_freq.target.repub, panel1dat[8,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[8])#
segments(panel1dat[9,]$log_freq.target.repub, panel1dat[9,]$dep, panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, lty=3)#
text(panel1dat[10,]$log_freq.target.repub, panel1dat[10,]$dep, pos=4, cex=0.7, labels=panel1dat$log_freq.const2.repub[10])#
#
#############################################
######## PANEL 4 (LENGTH=10) ###############
#############################################
#
panel4dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(10, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2,each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
pred_panel4dat=predman(panel4dat)#
#
panel4dat$dep=pred_panel4dat#
plot(panel4dat$log_freq.target.repub, panel4dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel4dat[1,]$log_freq.target.repub, panel4dat[1,]$dep, panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, lty=1) #
text(panel4dat[2,]$log_freq.target.repub, panel4dat[2,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[2])#
segments(panel4dat[3,]$log_freq.target.repub, panel4dat[3,]$dep, panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, lty=2)#
text(panel4dat[4,]$log_freq.target.repub, panel4dat[4,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[4])#
segments(panel4dat[5,]$log_freq.target.repub, panel4dat[5,]$dep, panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, lty=3)#
text(panel4dat[6,]$log_freq.target.repub, panel4dat[6,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[6])#
segments(panel4dat[7,]$log_freq.target.repub, panel4dat[7,]$dep, panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, lty=3)#
text(panel4dat[8,]$log_freq.target.repub, panel4dat[8,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[8])#
segments(panel4dat[9,]$log_freq.target.repub, panel4dat[9,]$dep, panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, lty=3)#
text(panel4dat[10,]$log_freq.target.repub, panel4dat[10,]$dep, pos=4, cex=0.7, labels=panel4dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 10#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 12", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 2 (LENGTH=12) ###############
#############################################
#
panel2dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel2dat=predman(panel2dat)#
#
panel2dat$dep=pred_panel2dat#
plot(panel2dat$log_freq.target.repub, panel2dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel2dat[1,]$log_freq.target.repub, panel2dat[1,]$dep, panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, lty=1) #
text(panel2dat[2,]$log_freq.target.repub, panel2dat[2,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[2])#
segments(panel2dat[3,]$log_freq.target.repub, panel2dat[3,]$dep, panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, lty=2)#
text(panel2dat[4,]$log_freq.target.repub, panel2dat[4,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[4])#
segments(panel2dat[5,]$log_freq.target.repub, panel2dat[5,]$dep, panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, lty=3)#
text(panel2dat[6,]$log_freq.target.repub, panel2dat[6,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[6])#
segments(panel2dat[7,]$log_freq.target.repub, panel2dat[7,]$dep, panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, lty=3)#
text(panel2dat[8,]$log_freq.target.repub, panel2dat[8,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[8])#
segments(panel2dat[9,]$log_freq.target.repub, panel2dat[9,]$dep, panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, lty=3)#
text(panel2dat[10,]$log_freq.target.repub, panel2dat[10,]$dep, pos=4, cex=0.7, labels=panel2dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 5 (LENGTH=12) ###############
#############################################
#
panel5dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(12, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel5dat=predman(panel5dat)#
#
panel5dat$dep=pred_panel5dat#
plot(panel5dat$log_freq.target.repub, panel5dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel5dat[1,]$log_freq.target.repub, panel5dat[1,]$dep, panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, lty=1) #
text(panel5dat[2,]$log_freq.target.repub, panel5dat[2,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[2])#
segments(panel5dat[3,]$log_freq.target.repub, panel5dat[3,]$dep, panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, lty=2)#
text(panel5dat[4,]$log_freq.target.repub, panel5dat[4,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[4])#
segments(panel5dat[5,]$log_freq.target.repub, panel5dat[5,]$dep, panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, lty=3)#
text(panel5dat[6,]$log_freq.target.repub, panel5dat[6,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[6])#
segments(panel5dat[7,]$log_freq.target.repub, panel5dat[7,]$dep, panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, lty=3)#
text(panel5dat[8,]$log_freq.target.repub, panel5dat[8,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[8])#
segments(panel5dat[9,]$log_freq.target.repub, panel5dat[9,]$dep, panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, lty=3)#
text(panel5dat[10,]$log_freq.target.repub, panel5dat[10,]$dep, pos=4, cex=0.7, labels=panel5dat$log_freq.const2.repub[10])#
###############
# LABEL LENGTH = 14#
##############
#
#par(mar = c(0,0,0,0)) #
#plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)#
#u <- par("usr")#
#text(1,u[4],labels = "Length = 14", pos = 1, cex=1.5)#
#
##########
##########
#
par(mar=c(5.1, 4.1, 4.1, 2.1))#
#par(mar = c(2,4,2,2) + 0.1)#
#############################################
######## PANEL 3 (LENGTH=14) ###############
#############################################
#
panel3dat=data.frame(typeNNsx=rep(1,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel3dat=predman(panel3dat)#
#
panel3dat$dep=pred_panel3dat#
plot(panel3dat$log_freq.target.repub, panel3dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel3dat[1,]$log_freq.target.repub, panel3dat[1,]$dep, panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, lty=1) #
text(panel3dat[2,]$log_freq.target.repub, panel3dat[2,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[2])#
segments(panel3dat[3,]$log_freq.target.repub, panel3dat[3,]$dep, panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, lty=2)#
text(panel3dat[4,]$log_freq.target.repub, panel3dat[4,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[4])#
segments(panel3dat[5,]$log_freq.target.repub, panel3dat[5,]$dep, panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, lty=3)#
text(panel3dat[6,]$log_freq.target.repub, panel3dat[6,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[6])#
segments(panel3dat[7,]$log_freq.target.repub, panel3dat[7,]$dep, panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, lty=3)#
text(panel3dat[8,]$log_freq.target.repub, panel3dat[8,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[8])#
segments(panel3dat[9,]$log_freq.target.repub, panel3dat[9,]$dep, panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, lty=3)#
text(panel3dat[10,]$log_freq.target.repub, panel3dat[10,]$dep, pos=4, cex=0.7, labels=panel3dat$log_freq.const2.repub[10])#
#############################################
######## PANEL 6 (LENGTH=14) ###############
#############################################
#
panel6dat=data.frame(typeNNsx=rep(0,10), log_freq.const1.repub=rep(median(stimuliNN$log_freq.const1.repub), 10),res_log_freq.const2.repub=rep(panels_freq.const2, each=2), length.target=rep(14, 10), log_freq.target.repub=rep(panels_comp.freq, 5), log_freq.const2.repub=rep(panels_or_freq.const2, each=2))#
#
# in pratica ho costruito un data.frame in cui le coppie successive di righe mi indicano i punti delle previsioni separatamente per frequenza const 2, prendendo due punti (iniziale e finale) della frequenza totale del composto.#
#
pred_panel6dat=predman(panel6dat)#
#
panel6dat$dep=pred_panel6dat#
plot(panel6dat$log_freq.target.repub, panel6dat$dep, type="n", ylim=c(5,8), xlim=c(0,8), ylab="Total View Duration", xlab="Compound frequency", main="")#
segments(panel6dat[1,]$log_freq.target.repub, panel6dat[1,]$dep, panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, lty=1) #
text(panel6dat[2,]$log_freq.target.repub, panel6dat[2,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[2])#
segments(panel6dat[3,]$log_freq.target.repub, panel6dat[3,]$dep, panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, lty=2)#
text(panel6dat[4,]$log_freq.target.repub, panel6dat[4,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[4])#
segments(panel6dat[5,]$log_freq.target.repub, panel6dat[5,]$dep, panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, lty=3)#
text(panel6dat[6,]$log_freq.target.repub, panel6dat[6,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[6])#
segments(panel6dat[7,]$log_freq.target.repub, panel6dat[7,]$dep, panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, lty=3)#
text(panel6dat[8,]$log_freq.target.repub, panel6dat[8,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[8])#
segments(panel6dat[9,]$log_freq.target.repub, panel6dat[9,]$dep, panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, lty=3)#
text(panel6dat[10,]$log_freq.target.repub, panel6dat[10,]$dep, pos=4, cex=0.7, labels=panel6dat$log_freq.const2.repub[10])
260+285+120+90.28+38.88
(260+285+120+90.28+38.88-410)
\name{erp.measure}#
\alias{erp.measure}#
%- Also NEED an '\alias' for EACH other topic documented here.#
\title{#
erp.measure#
}#
\description{#
This function calculates the mean amplitude, on several ERP \code{data.frame}. It returns results in "wide" format (each electrode in a columen) or in "long" format, a \code{data.frame}format more suitable for standard statistical analysis in R (e.g. ANOVA). \code{erp.mean} applies the function \code{mean} on several ERP \code{data.frame} objects, i.e. data.frames with timepoints on rows and electrodes on columns. ERP data.frames are expected to be named as a combination of strings specified in \code{base} and \code{numbers}. Differently from \code{\link{erp.fun}} this function returns a data.frame in long format (see Details).  #
}#
\usage{#
erp.measure(base, numbers, win.ini, win.end, env=.GlobalEnv, startmsec=-200, endmsec=1200, fun=average.mean, others=NULL, format="long", name.dep="Dep", name.newvar="Electrode")#
}#
%- maybe also 'usage' for other objects documented here.#
\arguments{#
#
\item{base}{#
A string indicating the beginning of the name of \code{data.frame} containg the ERP data.#
}#
  \item{numbers}{#
The numbers (indicating different subjects), to be averaged by the function.#
}#
  \item{win.ini}{#
A value indicating the initial edge (in ms) of the windows on which the peak amplitude has to be computed.#
}#
  \item{win.end}{#
A value indicating the final edge (in ms) of the windows on which the peak amplitude has to be computed.#
}#
  \item{env}{#
The environment in which \code{erp.fun} is to be evaluated.#
}#
  \item{startmsec}{#
A value indicating the initial time (in ms) of the ERP \code{data.frame} objects. It can be a negative value, indicating the baseline period.#
}#
  \item{endmsec}{#
A value indicating the final time (in ms) of the ERP \code{data.frame} objects.#
}#
  \item{others}{#
the name of others variables to be included in the returned \code{data.frame}. Ignored if format is "wide".#
}#
\item{format}{#
	the output format. It may be "wide" or "long".#
}#
\item{name.dep}{#
	the name of the dependent variable in the returned \code{data.frame}. Ignored if format is "wide".#
}#
#
}#
#
\details{#
This function returns a \code{data.frame} in long format ready for standard statistical analysis in R. It takes as input ERP \code{data.frame} with electrodes in separate columns. The returned \code{data.frame} has one column for dependent variable and a new factor "Electrode".#
}#
\value{#
a \code{data.frame} in long format. #
}#
#
\author{#
Giorgio Arcara#
}#
\note{#
this function is a wrapper for \code{\link{erp.fun}} and \code{\link{rearrange}}#
}#
\seealso{#
\code{\link{erp.peak}}, \code{\link{erp.latency}}, \code{\link{rearrange}},  \code{\link{mean}} #
#
}#
\examples{#
erp.mean(base="Exp1_word_subj", numbers=1:20, win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
		others=c(condition="word"], interval="130-190", name.dep="Ampl", format="long"))#
}
library(erpR)
?erpR
remove.packages(erpR)
remove.packages("erpR")
?erpR
library(erpR)
?erpR
library(erpR)
?erpR
?erp
erp()
library(erpR)
?erpR
?erp
citations(erpR)
citation(erpR)
?erpR
citation("erpR")
Subject=rnorm(20, 500, 80)
Subject
simulate the effects of three experimental conditions#
condA=rnorm(20, 40, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)
library(erpR)
dat=data.frame(Subject=rep(1:20,3), conditions=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subRT+condC ))
simulate some subjects#
subjRT=rnorm(20, 500, 100)#
#
#simulate the effects of three experimental conditions#
condA=rnorm(20, 40, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)#
#
dat=data.frame(Subject=rep(1:20,3), conditions=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subRT+condC ))
dat=data.frame(Subject=rep(1:20,3), conditions=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subjRT+condC ))
head(dat)
tapply(dat$RT, dat$conditions, mean)
simulate some subjects#
subjRT=rnorm(20, 500, 100)#
#
#simulate the effects of three experimental conditions#
condA=rnorm(20, 50, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)#
#
dat=data.frame(Subject=rep(1:20,3), conditions=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subjRT+condC ))
library(erpR)
tpairs(dat, "all", "RT", "Subject")
head(dat)
?tpairs
tpairs(dat, "condition", "all", "RT", "Subject")
tpairs(dat, "conditions", "all", "RT", "Subject")
simulate some subjects#
subjRT=rnorm(20, 500, 100)#
#
#simulate the effects of three experimental conditions for each subject#
condA=rnorm(20, 50, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)#
#
#create a data frame#
dat=data.frame(Subject=rep(1:20,3), conditions=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subjRT+condC ))#
#
#perform pairwise t.test#
tpairs(dat, "condition", "all", "RT", "Subject")
simulate some subjects#
subjRT=rnorm(20, 500, 100)#
#
#simulate the effects of three experimental conditions for each subject#
condA=rnorm(20, 50, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)#
#
#create a data frame#
dat=data.frame(Subject=rep(1:20,3), condition=c(rep("A", 20), rep("B", 20), rep("C", 20)), RT=c(subjRT+condA, subjRT+condB, subjRT+condC ))#
#
#perform pairwise t.test#
tpairs(dat, "condition", "all", "RT", "Subject")
tpairs(dat, "condition", "all", "RT", "Subject", var.equal=T)
tpairs <-#
function(dat, vars, contr, dep, wid, p.adjust.methods="none", paired=FALSE, type="t.test", vars.bet=NULL,...){#
#
		dat$newfactor=apply(data.frame(dat[,vars]), 1, function(x){paste(x, collapse="_")})#
		dat$newfactor=factor(dat$newfactor)	#
		dat=aggregate(dat[,dep], list(dat$newfactor, dat[,wid]), mean)#
		names(dat)=c("newfactor", "wid", dep)#
		contrast.names=NULL#
		p.values=NULL#
		t.values=NULL#
		df=NULL#
		mean.1=NULL#
		mean.2=NULL#
			if (contr[[1]][[1]]=="all"){#
			combs=combn(levels(dat$newfactor),2)#
		contr=list(NULL)#
		length(contr)=dim(combs)[2]#
			for (k in 1:dim(combs)[2]){#
				contr[[k]]=combs[,k]#
				}#
			}#
		for (i in 1:length(contr)){ #forse puoi evitare questo ciclo con un lapply..#
			res=t.test(dat[dat$newfactor%in%contr[[i]][[1]],dep],dat[dat$newfactor%in%contr[[i]][[2]],dep], 		paired=paired,...)#
		contrast.names=c(contrast.names, paste(contr[[i]][[1]], "vs", contr[[i]][[2]], sep=" "))#
		p.values=c(p.values, res$p.value)#
		t.values=c(t.values, res$statistic)#
		df=c(df, res$parameter)#
		mean.1=c(mean.1, mean(dat[dat$newfactor%in%contr[[i]][[1]],dep]))#
		mean.2=c(mean.2, mean(dat[dat$newfactor%in%contr[[i]][[2]],dep]))#
		}	#
		p.values.corr=round(p.adjust(p.values, p.adjust.methods),3)#
		results=data.frame(contr=contrast.names, p.value=p.values.corr, t.value=t.values, df=df, mean.1=mean.1, mean.2)#
		attr(results, "p.corr")=p.adjust.methods#
		cat("p values adjustment = ", p.adjust.methods, "\n")#
		return(results)#
}
tpairs(dat, "condition", "all", "RT", "Subject", var.equal=T)
library(erpR)
questa funzione si interfaccia con la funzione exportpicture_02_h, che esporta fil .eeg che contengono eeg.#
#
import.erp=function(filenamebase,numbers, ext=".txt", outname="ERP_subj", envir=.GlobalEnv, filename=TRUE){#
	for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ".txt",sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		if (filename==FALSE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
}
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
rm(import.erp)
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
questa funzione si interfaccia con la funzione exportpicture_02_h, che esporta fil .eeg che contengono eeg.#
#
import.erp=function(filenamebase,numbers, ext=".txt", outname="ERP_subj", envir=.GlobalEnv, filename=TRUE){#
	for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		if (filename==FALSE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
#
}
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
filenamebase="Exp1_word_subj"; numbers=1:20; outname="Exp1_word_subj"
ext=".txt"
envir=.GlobalEnv
filename=TRUE
i=1
eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)
eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)
eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")
assign(eegout.name, eegout, envir=envir)
for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
		if (filename==FALSE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}
i
questa funzione si interfaccia con la funzione exportpicture_02_h, che esporta fil .eeg che contengono eeg.#
#
import.erp=function(filenamebase,numbers, ext=".txt", outname="ERP_subj", envir=.GlobalEnv, filename=TRUE){#
	for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
		if (filename==FALSE){#
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
	}#
#
}
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
import.erp(filenamebase="Prova_", numbers=1:2, outname="Exp1_word_subj")
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_")
prova_1
head(prova_1)
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_" filename=F)
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_",filename=F)
head(prova_1)
rm(prova_1, prova_2)
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_",filename=F)
questa funzione si interfaccia con la funzione exportpicture_02_h, che esporta fil .eeg che contengono eeg.#
#
import.erp=function(filenamebase,numbers, ext=".txt", outname="ERP_subj", envir=.GlobalEnv, filename=TRUE){#
	for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		} #
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
		if (filename==FALSE){#
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
	}#
#
}
questa funzione si interfaccia con la funzione exportpicture_02_h, che esporta fil .eeg che contengono eeg.#
#
import.erp=function(filenamebase,numbers, ext=".txt", outname="ERP_subj", envir=.GlobalEnv, filename=TRUE){#
	for (i in 1:length(numbers)){#
		if (filename==TRUE){#
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T,skip=1)#
		eeg.subjectname=readLines(paste(filenamebase, numbers[i], ext,sep=""), n=1)#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
		if (filename==FALSE){#
		eegout=read.table(paste(filenamebase, numbers[i], ext ,sep=""), header=T)#
		eeg.subjectname=paste(filenamebase, numbers[i], ext ,sep="")#
		eeg.subjectname=gsub("\t","", eeg.subjectname)#
		comment(eegout)=eeg.subjectname#
		eegout.name=paste(outname, numbers[i], sep="")#
		assign(eegout.name, eegout, envir=envir)#
		}#
	}#
#
}
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_",filename=F)
head(prova_1)
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_",filename=T)
head(prova_1)
import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj")
head(Exp1_word_subj1)
comment(Exp1_word_subj1)
comment(prova_1)
import.erp(filenamebase="Prova_", numbers=1:2, outname="prova_",filename=F)
comment(prova_1)
citations(erpR)
citation("erpR")
remove.packages(erpR)
remove.packages("erpR")
library(erpR)
?erpR
library(erpR)#
data(ERPsets)#
word=grandaverage("Exp1_word_subj", 1:20) #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
Import data#
#############################################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,200), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
#############################################
### Create a data frame with all the information#
#############################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# The data frame is in wide format which is not yet suitable for analyses like Anova or mixed models.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of
format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
# Transform the Subject in factor to avoid problems in future analyses (e.g. aov)#
datall.long$Subject=factor(datall.long$Subject)#
#############################################
### Create a data frame for the analysis#
#############################################
### EXAMPLE 1#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=Agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
### EXAMPLE 2
Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)
ls()
head(Exp1_nonword_subj1)
head(datall.long)
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)
intervals=list(c(130,190), c(400,600), c(500, 700))
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
#############################################
### Create a data frame with all the information#
#############################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# The data frame is in wide format which is not yet suitable for analyses like Anova or mixed models.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be neces
Create a data frame for the analysis#
#############################################
### EXAMPLE 1#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)
EXAMPLE 2#
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))
Perform ANOVA#
########################
# before ANOVA, transform all relevant variables in factors#
factor(dat400600$Subject)#
factor(dat400600$condition)#
factor(dat400600$laterality)#
factor(dat400600$caudality)
dat400600
str(dat400600)
factorall <-#
function(x){#
	for(i in 1:length(x)){#
		{#
			x[,i]=factor(x[,i])}#
		}#
		return(x)#
	}
dat400600[,c("Subject", "laterality", "caudality", "condition")]=factorall(dat400600[,c("Subject", "laterality", "caudality", "condition")])
str(dat400600)
dat400600[,c("Subject")]=factorall(dat400600[,c("Subject")])
dim(x)
dim(dat400600)
dim(dat400600[,c("Subject", "laterality")])
dim(dat400600[,c("Subject")])
length(dim(dat400600[,c("Subject")]))
length(dim(dat400600[,c("Subject", "laterality")]))
factorall <-#
function(x){#
	if (length(dim(x))>1){#
		for(i in 1:length(x)){#
			{#
				x[,i]=factor(x[,i])}#
			}#
		return(x)#
		} else {#
		x=factor(x)#
		return(x)#
		}#
	}
factorall(dat400600[,c("Subject", "condition")])
str(factorall(dat400600[,c("Subject", "condition")]))
dat400600
str(dat400600)
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)
str(factorall(dat400600[,c("Subject", "condition")]))
str(factorall(dat400600[,c("Subject")]))
data(iris)#
iris2 <- iris[iris$Species!="setosa", ]#
levels(iris2$Species)#
iris2<-factorall(iris2[,"Species"])#
levels(iris2$Species)
iris2
data(iris)#
iris2 <- iris[iris$Species!="setosa", ]#
levels(iris2$Species)#
iris2$Species<-factorall(iris2[,"Species"])#
levels(iris2$Species)
head(iris)
data(iris)#
iris2 <- iris[iris$Species!="setosa", ]#
levels(iris2$Species)#
iris2[,c("Petal.Width", "Species")]<-factorall(iris2[,c("Petal.Width", "Species"])#
levels(iris2$Species)
iris2 <- iris[iris$Species!="setosa", ]#
levels(iris2$Species)#
iris2[,c("Petal.Width", "Species")]<-factorall(iris2[,c("Petal.Width", "Species")])#
levels(iris2$Species)
str(iris2)
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])
str(dat400600)
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)
Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))
scalp(list(word), smo=0, layout=1, ylim=10)
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
?scalp.infl
erp.infl <-#
function(base, numbers, electrode, smo=0, startmsec=-200, endmsec=1200, lwd=1, lty=1, envir=.GlobalEnv, ...){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
erp.infl.panel=function(panel)#
	{#
#
		erp.infl.endo=function(base, numbers, electrode, outline, smo=0 , col="black", startmsec=-200, endmsec=1000, interval=c(startmsec, endmsec), step=200, verticals=NULL,horizontals=NULL, x.axis="default", ylim=c(-10,10), lwd=1, lty=1,out.col="red", envir)#
	{#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],"$",electrode, sep="")), envir=envir)#
		for (i in 2:length(numbers))#
		{#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i],"$",electrode, sep="")), envir=envir)		#
		}#
		average=average.temp/length(numbers)#
		erp(average,smo=smo, col=col, startmsec=startmsec, endmsec=endmsec, interval=interval,step=step, verticals=verticals, horizontals=horizontals, x.axis=x.axis, ylim=ylim, lwd=lwd, lty=lty,main=electrode, ...)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline,"$",electrode, sep="")), envir=envir))/(length(numbers)-1)#
		erp.add(average.excl, col=out.col, lwd=2, smo=smo)#
	legend("topright", legend=c("Average all", paste("Average no subj", outline)), pch=15, col=c(col,out.col), pt.bg=c(1:6), cex=1.2)#
		}							#
		erp.infl.endo(base=base, numbers=numbers, electrode=electrode, outline=panel$outnumber, smo=smo, startmsec=startmsec, endmsec=endmsec, envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = erp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, erp.infl.panel)#
   }
scalp.infl <-#
function(base, numbers, smo=0, layout=3, ylims=12, yrev=FALSE, startmsec=-200, endmsec=1200, lwd=c(1,2), lty=1, col="black", out.col="red", envir=.GlobalEnv){#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
scalp.infl.panel=function(panel)#
	{#
		scalp.infl.endo=function(base, numbers, outline, smo, col, startmsec, endmsec, yrev, ylims, lwd, lty, color.list=c("black","red"), layout, envir=.GlobalEnv){#
		text=paste(base,numbers[1],sep="")#
		average.temp=eval(parse(file="", text=paste(base,numbers[1],sep="")), envir=envir)#
		for (i in 2:length(numbers)){#
			average.temp=average.temp+eval(parse(file="", text=paste(base,numbers[i], sep="")),envir=envir)		#
			}#
		average=average.temp/length(numbers)#
		average.excl=(average.temp-eval(parse(file="", text=paste(base,outline, sep="")),envir=envir))/(length(numbers)-1)#
#
		scalp.endo=function(categ, smo=0.5, label=c("type1"), layout=1, ylims, yrev=TRUE, startmsec=-200, 	endmsec=1200, lwd=1, lty=1, color.list=c("black","red")) {#
#
	if (length(lwd)==1){#
		lwd=rep(lwd, length(categ))}#
	if (length(lty)==1){#
		lty=rep(lty, length(categ))}#
#
	if (class(categ)!="list"){#
			stop("input object must be a list!!")}#
if (layout==1){#
electrodes=c("axes","Fp1", "blank", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T3", "C3", "CZ","C4","T4","TP7", "CP3", "CPZ", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "OZ", "O2", "blank")#
	}#
	if (layout==2){#
	electrodes=c("axes","Fp1", "FPZ", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCZ", "FC4", "FT8", "T7", "C3", "CZ","C4","T8","TP7", "CP3", "CPZ", "CP4", "TP8", "P7", "P3", "PZ", "P4", "P8", "blank", "O1", "OZ", "O2", "blank")#
	}#
		if (layout==3){#
	electrodes=c("axes","Fp1", "Fpz", "Fp2","legend", "F7", "F3", "FZ", "F4", "F8", "FT7", "FC3", "FCz", "FC4", "FT8", "T3", "C3", "Cz","C4","T4","TP7", "CP3", "CPz", "CP4", "TP8", "T5", "P3", "PZ", "P4", "T6", "blank", "O1", "blank", "O2", "blank")#
	}#
		if (layout==4){#
		electrodes=c("axes", "Fp1", "blank", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "FCz", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "blank", "CP1", "CPz", "CP2", "blank", "P7", "P3", "Pz", "P4", "P8", "blank","O1","blank", "O2", "blank")#
		}#
	if (layout==5){#
		electrodes=c("axes", "Fp1", "Fpz", "Fp2", "legend","blank", "AF3", "blank", "AF4", "blank", "F7", "F3", "Fz", "F4", "F8", "FC5", "FC1", "blank", "FC2", "FC6", "T7", "C3", "Cz", "C4", "T8", "CP5", "CP1", "blank", "CP2", "CP6", "P7", "P3", "Pz", "P4", "P8","PO7", "PO3", "POz", "PO4", "PO8", "blank","O1","Oz", "O2", "blank" )#
		}		#
	## ci sono incongruenze con le etichette degli elettrodi. Per non fermarmi le cambio momentaneamente nella 		seguente #maniera T7=T3, T4=T8, P7=T5, T6=P8#
#
	if (ylims=="auto"){#
		## mergio tutti i dataset per riscalare gli assi rispetto a massimo e minimo #
		alldata=NULL#
			for (i in 1:length(categ)){#
				alldata=rbind(alldata, categ[[i]])#
			}#
		ymax=max(alldata)#
		ymin=min(alldata)#
		yedge=max(c(ymax, abs(ymin)))#calcolo questo yedge in modo da fare limiti delle y simmetrici#
		# aggiungo una perecentuale per evitare che il grafico sbordi (il)#
		yedge=c(-yedge,yedge)#
		}#
	if (ylims!="auto"){#
		yedge=ylims#
		yedge=c(-ylims, ylims)#
		}	#
#
	if (yrev==TRUE){#
		yedge=sort(yedge, decreasing=T)#
		}#
#
	oldpar <- par(no.readonly=TRUE) #questo pezzo è per risettare alla fine della funzione i vecchi parametri. L'ho preso da "An introduction to R" pag. 68. Vedi anche sotto.#
#
	par(mfrow=c(7,5), mai=c(0,0,0,0))#
	if (layout==5)#
   {#
   par(mfrow=c(10,5), mai=c(0,0,0,0))#
   }#
   if (layout==4)#
   {#
   par(mfrow=c(8,5), mai=c(0,0,0,0))#
   }#
	plot(categ[[1]]$P4, type="n", frame.plot=FALSE,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)))#
	axis(side=2, pos= dim(categ[[1]])[1]/2, at=c(round(ceiling(yedge[1]),0),round(ceiling(yedge[1])/2,0),0,round(floor(yedge[2])/2,0),round(floor(yedge[2]),0)), cex.axis=0.8, las=2)#
	text((dim(categ[[1]])[1]/2)+(dim(categ[[1]])[1]/8),0, labels=expression(paste(mu,"V")), cex=1.4)#
		for (i in 2:(length(electrodes))){#
			if (electrodes[i]=="blank") {#
				plot.new()#
			}#
			if (electrodes[i]=="legend"){#
				plot.new()#
	legend("center", legend=c("Average all", paste("Average no subj", outline)), lty=lty, col=color.list, cex=1.2, lwd=lwd)#
#
			}#
			if (electrodes[i]!="blank"&electrodes[i]!="axes"&electrodes[i]!="legend") {#
				plot(smooth.spline(categ[[1]][[electrodes[i]]][1:dim(categ[[1]])[1]], spar=smo), type="l", ylim=c(yedge[1]+yedge[1]/3,yedge[2]+(yedge[2]/3)),col=color.list[1], main="", ylab="", xlab="", cex.main=0.85,xlim=c(1,dim(categ[[1]])[1]),xaxt="n",yaxt="n",frame.plot=FALSE, lwd=lwd[1], lty=lty[1])#
				##### di seguito ho semplicemente calcolato, tramite una proporzione, il punto che corrisponde allo 0#
					totalendmsec=endmsec+abs(startmsec)#
					zeropoint=(abs(startmsec)*dim(categ[[1]])[1])/totalendmsec#
					segments(x0=zeropoint, y0=-0.8, x1=zeropoint, y1=0.5, lwd=1.5)#
					abline(h=0, lty="longdash")#
					mtext(electrodes[i],side=3, line=-2)#
		if (length(categ)>1&electrodes[i]!="blank") {#
					for (k in 2:length(categ)){#
						lines(smooth.spline(categ[[k]][electrodes[i]], spar=smo),col=color.list[k], lwd=lwd[k],lty=lty[k])#
						}#
			} #
			}#
		}#
	par(oldpar)#questo pezzo è per resettare alla fine della funzione i vecchi parametri. L'ho preso da "An #
	#introduction to R" pag. 68. Vedi anche sotto.#
	}#
		scalp.endo(list(average, average.excl),smo=smo,color.list=color.list, startmsec=startmsec, endmsec=endmsec, ylims=ylims, yrev=yrev, lwd=lwd, lty=lty, layout=layout)	#
		}#
		scalp.infl.endo(base=base, numbers=numbers, outline=panel$outnumber, layout=layout, smo=smo, ylims=ylims, yrev=yrev, startmsec=startmsec, endmsec=endmsec, color.list=c(col, out.col), lwd=lwd, lty=lty,envir=envir)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = scalp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, scalp.infl.panel)#
   }
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))
scalp(list(nonword), smo=0, layout=1, ylim=10)
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))
Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1
Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
temp="\code{data.frame}"
temp="\\code{data.frame}"
temp
curr.dir="~/Desktop/R files/erpr/pkg/R"#
setwd(curr.dir)#
#
files=dir()
i=1
files
files[i]
i)4
i=4
temp=readLines(files[i])
temp
curr.dir="~/Desktop/R files/erpr/pkg/man"
setwd(curr.dir)
files=dir()
i=4
temp=readLines(files[i])
temp
temp=gsub("\\code{data.frame}", "data frame", temp)
?erp.mean
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long")
head(dat)
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="wide")
head(dat)
curr.dir="~/Desktop/R files/erpr/pkg/man"#
setwd(curr.dir)#
#
files=dir()#
#
dir.create(paste("../nuovoman", sep=""))#
#
for (i in 1:length(files)){#
	temp=readLines(files[i])#
	temp=gsub("comment.dat", "fileinfo", temp)#
	writeLines(temp, paste("../nuovoman/", files[i],sep=""))#
}
curr.dir="~/Desktop/R files/erpr/pkg/R"#
setwd(curr.dir)#
#
files=dir()#
#
dir.create(paste("../nuovoman", sep=""))#
#
for (i in 1:length(files)){#
	temp=readLines(files[i])#
	temp=gsub("comment.dat", "fileinfo", temp)#
	writeLines(temp, paste("../nuovoman/", files[i],sep=""))#
}
curr.dir="~/Desktop/R files/erpr/pkg/R"#
setwd(curr.dir)#
#
files=dir()#
#
dir.create(paste("../nuovoman", sep=""))#
#
for (i in 1:length(files)){#
	temp=readLines(files[i])#
	temp=gsub("comment.dat", "fileinfo", temp)#
	writeLines(temp, paste("../nuovoman/", files[i],sep=""))#
}
citation("erpR")
rm(list=ls())
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "condition", "Electrode")]=factorall(dat400600[,c("Subject", "condition", "Electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "condition", "Electrode")]=factorall(dat400600[,c("Subject", "condition", "Electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])
factorall
datmidline
str(datmidline)
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])
str(datmidline)
remove.packages("erpR")
erpR SAMPLE PIPELINE#
#############################################
#
################
## Load package#
#################
# install erpR package #
#install.packages("erpR")#
# load erpR package#
library(erpR)#
#################
### Import data#
##################
# to play around with erpR you can load directly the data frames included in the package#
# load the sample datasets#
data(ERPsets)#
# alternatively you may import .txt data (you can download the same examples contained in ERPdatasets from XXXXX) #
# by running the following lines#
### change path, by setting YOUR path of the folder containing the .txt files #
#setwd("~/Desktop/pacchetto erpR/files example erpR")#
#
# load all the files of "word" condition. "Outname" indicates the name that will be given to the object in R#
#import.erp(filenamebase="Exp1_word_subj", numbers=1:20, outname="Exp1_word_subj", filename=TRUE)#
#
# load all the files of the "nonword" condition#
#import.erp(filenamebase="Exp1_nonword_subj", numbers=1:20, outname="Exp1_nonword_subj")#
######################################
### Create a data frame with all data#
#######################################
# The next steps lead to creating a data frame "datall.long" that contains all the necessary information for the analysis.#
# In these 2 nested cycles we calculate an average across all subjects for each selected interval. #
# Create a list with couples of numbers that indicate the intervals for which mean amplitude will be calculated#
intervals=list(c(130,190), c(400,600), c(500, 700))#
# Create a vector of experimental conditions, that will be used for naming the final datased.#
# The "base" part of the filename be uniform for all the files of the same experimental condition, varying only by subject number added at the end.#
# E.g. we have two conditions - "word" and "nonword", so the "word" files may be named like "Exp1_word_subj1", "Exp1_word_subj2" etc.#
#
bases=c("Exp1_word_subj", "Exp1_nonword_subj")#
conditions=c("WORD", "NONWORD")#
# Create an empty dataframe before starting the cycle #
datall.long=NULL#
# Fill the data frame#
# "Numbers" indicate the numbers of the subjects.#
for (int in 1:length(intervals))#
	{#
	for (k in 1:length(conditions)){#
		temp=erp.mean(base=bases[k], numbers=1:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2], startmsec=-200, endmsec=1500,#
		others=c(condition=conditions[k], interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", format="long")#
			datall.long=rbind(datall.long, temp)#
		}#
	}#
#############################################
# Note: the above cycle works well in case of a within-subject experimental design.#
# In case of a between-subject design it will be necessary to make separate cycles for each condition, where one may change the "base" #
# (if different experimental groups have different "base" name), the "numbers" (if the subjects from different groups have different numbers), or both of them.#
# This depends on the encoding made during the experiment.#
#############################################
#
### for example, assuming that the word condition has been administered to the subject 1 to 10, and the nonword to 11 to 20.#
# the following cycle #
##
# datall.long=NULL#
##
# for (int in 1:length(intervals))#
#	{#
#	for (k in 1:length(conditions)){#
#		temp1=erp.mean("Exp1_word_subj", numbers=1:10, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200,#
# endmsec=1500, others=c(condition="word", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl", #
# format="long")#
#		temp2=erp.mean("Exp1_nonword_subj", numbers=11:20, win.ini=intervals[[int]][1], win.end=intervals[[int]][2],  startmsec=-200, #
# endmsec=1500, others=c(condition="nonword", interval=paste(intervals[[int]][1], "-", intervals[[int]][2], sep="")), name.dep="Ampl",#
# format="long")#
#		#
#			datall.long=rbind(datall.long, temp1, temp2)#
#	}#
##############################################################
### Create a data frame suitable for the statistical analysis#
###############################################################
#############################################
### Example 1: analysis on midline electrode#
##############################################
#
# Compare the amplitudes between some electrodes of the midline#
# Create an object selecting the electrodes for the analysis#
datall.long.midline=datall.long[datall.long$Electrode%in%c("FPZ", "FZ", "CPZ"),]#
# Group the data so that ANOVA works correctly#
# The function below does this grouping, calculating the mean of the data for all the conditions to collapse.#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "130-190"#
datmidline=named.agg(Ampl~condition+Electrode+Subject, data=datall.long.midline[datall.long.midline$interval=="130-190",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(datmidline, table(Electrode, Subject, condition))#
# before ANOVA, transform all relevant variables in factors#
datmidline[,c("Subject", "condition", "Electrode")]=factorall(datmidline[,c("Subject", "condition", "Electrode")])#
# compute ANOVA#
datmidline.aov=aov(Ampl~condition*Electrode+Error(Subject/(condition*Electrode)), datmidline)#
summary(datmidline.aov)#
###################################
### Example 2: analysis on two ROI#
####################################
# Group the electrodes for ROI (region of interest)#
# As a first step, create the variables that group the electrodes.#
# Create two vectors to define laterality of the ROI (two levels: "left", "right")#
datall.long$laterality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "C3", "CP3"), c("F4", "FC4", "C4", "CP4")), roi.levels=c("left", "right"))#
# Check for correct grouping#
table(datall.long$laterality, datall.long$Electrode)#
# Create other grouping variables#
datall.long$caudality=create.roi(datall.long, Electrode="Electrode", groups=list(c("F3", "FC3", "F4", "FC4"), c("C3", "CP3", "C4", "CP4")), roi.levels=c("anterior", "posterior"))#
# Check for correct grouping#
table(datall.long$caudality, datall.long$Electrode)#
# Group the data so that ANOVA works correctly#
#The function below does this grouping, calculating the mean of the data for all the conditions to collapse (this is specified in FUN=mean)#
# Define 1) the dependent variable, 2) all and only the independent variables for the analysis, 3) Subject variable#
# Here the analysis is confined to the interval "400-600"#
dat400600=named.agg(Ampl~caudality+laterality+condition+Subject, data=datall.long[datall.long$interval=="400-600",], FUN=mean)#
# Check that the data is organized correctly. #
# If it is, a single value should be returned for each combination of all the variables, including Subject, EXCEPT the dependent variable (Ampl in this case)#
with(dat400600, table(caudality, laterality, condition, Subject))#
# before ANOVA, transform all relevant variables in factors#
dat400600[,c("Subject", "caudality", "laterality", "condition")]=factorall(dat400600[,c("Subject", "caudality", "laterality", "condition")])#
#
# compute ANOVA#
dat400600.aov=aov(Ampl~condition*caudality*laterality+Error(Subject/(condition*caudality*laterality)), dat400600)#
summary(dat400600.aov)#
#######################
# Graphics#
#######################
# Create an average of all the subjects for the "word" condition#
word=grandaverage("Exp1_word_subj", 1:20) #
# Create an average of all the subjects for the "nonword" condition#
nonword=grandaverage("Exp1_nonword_subj", 1:20)#
# Visualize a single electrode of the grand average of all the subjects #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500)#
# Add nonword diagram to the word one#
erp.add(nonword$Fp1, col="red", smo=0)#
# Visualize a single electrode of a single subject (subj1 here)#
erp(Exp1_word_subj1$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-20,20))#
# Visualize the whole scalp for all the subjects#
scalp(list(word), smo=0, layout=1, ylim=10)#
# From this diagram we see an anomaly in OZ#
# The following diagrams help to track the OZ anomaly origins#
# Visualize if there are subjects that have a particular influence on the average#
# Requires Rpanel and Tcl/Tk packages#
scalp.infl("Exp1_word_subj", 1:20, layout=1, startmsec=-200, endmsec=1500)#
# Note that Subject 1 is clearly particularly influential for the average on OZ.#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", startmsec=-200, endmsec=1500)#
#The anomaly of the Subject 1 on OZ is also visible on a Butterfly plot#
butterfly(base="Exp1_word_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# Check the grand average of the nonword condition as well#
scalp(list(nonword), smo=0, layout=1, ylim=10)#
# Here's also an anomaly#
butterfly(base="Exp1_nonword_subj", numbers=1:20, electrode="OZ", smo=0, startmsec=-200, endmsec=1500, outline=1, ylim=c(-50,50))#
# The Butterfly plot confirms that the problem is in the Subject 1.#
#Create a backup of Subject 1#
Exp1_word_subj1_backup=Exp1_word_subj1#
Exp1_nonword_subj1_backup=Exp1_nonword_subj1#
# Modify the Subject 1 changing the data we want to exclude to NA.#
Exp1_word_subj1$OZ=NA#
Exp1_nonword_subj1$OZ=NA#
# Create an object that contains the average of all the subjects for the "word" condition#
word.adj=grandaverage("Exp1_word_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Create an object that contains the average of all the subjects for the "nonword" condition#
nonword.adj=grandaverage("Exp1_nonword_subj", 1:20, NA.sub=T)#
# Note the warning that something abnormal has been done#
# Check OZ#
scalp(list(word, word.adj), smo=0, layout=1, ylim=10, legend=T)#
# Note that this diagram and the previous one are identical except for the OZ#
# Check the differences word-nonword#
scalp(list(word.adj, nonword.adj), smo=0, layout=1, ylim=10, legend=T)#
# Exploratory t-tests for every timepoint. Grey bands indicate significant differences for a given timepoint.#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, layout=1, ylim=10, legend=T)
factorall
detach(package:erpR)
remove.packages("erpR")
library(erpR)
?erpR
?create.mean
library(erpR)
?factorall
