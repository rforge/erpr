erp.xaxis(100)
erp.xaxis(100, x.labels.pos = 2)
erp.xaxis(100, x.labels.pos = 3)
erp.xaxis(100, x.labels.pos = 5)
erp.xaxis
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	par(mgp = new.mgp)#
}#
#
axis(1, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
plot(1:10, xlim=c(-200, 1200), axes=F)
erp.xaxis(100, x.labels.pos = 1)
erp.xaxis(100, x.labels.pos = -3)
?options
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
axis(1, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
erp.xaxis(100, x.labels.pos = -3)
erp.xaxis(100, x.labels.pos = -5)
par()$mgp
msectopoints<-function(a, lengthsegment, startmsec, endmsec){#
	#lengthsegment=lengthsegment-1#
	totmsec=endmsec-(startmsec) #total duration in msec#
	msecstep=(lengthsegment-1)/totmsec #how many points is a msec. #
	# notice the - 1. This is because it doesn't make sense to say how many point is a msec.#
	# what you actually are counting is how many points there are between two msec#
	# each msec step is not single point, but the space between two points (a small segment between two msec). For this reason you have to subtract one.#
	x=(a-startmsec)*msecstep#
	return(x+1)#
	# notice that you return x+1. This is because the points in your vector goes from 1 to length of the vector.#
	# when you are at point 1. you are at step 0 (i.e., no "small segment"). The maximum number of segment you can reach is lengthsegment-1.#
	}
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
library(erpR)
?erp
data(ERPsets)#
word=grandaverage("Exp1_word_subj", 1:20) #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
erp.xaxis(dim(word)[1])
data(ERPsets)#
word=grandaverage("Exp1_word_subj", 1:20) #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
erp.xaxis(dim(word)[1], endmsec=1500)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=-seq(-200, 1500, 200))
data(ERPsets)#
word=grandaverage("Exp1_word_subj", 1:20) #
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=-seq(-200, 1500, 200))
plot(word, type="l", axes=F)
plot(word,  axes=F)
plot(word)
word()
plot(word$Fp1, type="l")
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=-seq(-200, 1500, 200))
dim(word)[1]
debug(erp.xaxis)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=-seq(-200, 1500, 200))
ticksandlab
x.labels
x.labels=seq(-200, 1200, 200)
x.labels
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
Q
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
debug(erp.xaxis)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=-seq(-200, 1500, 200))
x.labels
seq(-200, 1200, 200)
Q
undebug(erp.xaxis)
debug(erp.xaxis)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
x.labels
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
par(oldpar)#
}
Q
plot(word$Fp1, type="l")
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
!
Q
undebug(erp.xaxis)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.labels.pos=-5)
?axis
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=0.5)
?axis
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
#
if (tick.both=TRUE){#
axis(1, at= ticksandlab, labels=NULL, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels=NULL, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=0.5)
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5)
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE, cex.xaxis = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl, cex = cex.xaxis)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T, cex.xaxis=2)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T, cex.xaxis=3)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE, x.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl, cex.lab = x.cex)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T, x.cex=3)
?axis
?par
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE, x.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl, cex.axis = x.cex)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.tcl=-0.5, tick.both=T, x.cex=3)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd=2, tick.both=T)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.tick.lwd=2, tick.both=T)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T)
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T, x.pos=4)
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T, x.pos=4)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, tick.both= FALSE, x.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl, cex.axis = x.cex)#
#
if (tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
this function is basically a wrapper for ayis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly ayis (see also par).#
#
erp.yayis <- function (y.labels=seq(-6,6,2), y.labels.pos = 1, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, tick.both= FALSE, y.cey = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
ayis(1, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cey.ayis = y.cey)#
#
if (tick.both==TRUE){#
ayis(1, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.yaxis <- function (y.labels=seq(-6,6,2), y.labels.pos = 1, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, tick.both= FALSE, y.cey = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
axis(1, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cey.axis = y.cey)#
#
if (tick.both==TRUE){#
axis(1, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T, x.pos=4)
erp.yaxis(, y.lwd=2, y.lwd.ticks=2, tick.both=T)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.xaxis <- function (length.erp = NULL, startmsec=-200, endmsec = 1200, x.labels=seq(-200, 1200, 200), x.labels.pos = 1, x.pos = NA, x.tick = seq(-200, 1200, 200) , x.outer = F, x.font = NA, x.lty = "solid", x.lwd = 1, x.lwd.ticks = 1, x.col = NULL, x.col.ticks = NULL, x.padj = NA, x.tcl = -0.5, x.tick.both= FALSE, x.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
#
if (is.null(length.erp)){#
	stop("the length of the erp waveform need to be specified.\n The axis is drawn taking into account this length and the two parameters starmsec and endmsec", call.=F)#
}#
#
if (x.labels.pos!="default"){#
	new.mgp = par()$mgp#
	# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
	new.mgp[2]=x.labels.pos#
	# disable warning messages#
	options(warn=-1)#
	par(mgp = new.mgp)#
	# re-enable warning messages#
	options(warn=1)#
}#
#
# tick and labels positions#
ticksandlab=msectopoints(x.labels, length.erp, startmsec, endmsec)#
#
axis(1, at= ticksandlab, labels=x.labels, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = x.tcl, cex.axis = x.cex)#
#
if (x.tick.both==TRUE){#
axis(1, at= ticksandlab, labels= FALSE, pos= x.pos, tick = x.tick, outer = x.outer, font = x.font, lty = x.lty, lwd = x.lwd, lwd.ticks = x.lwd.ticks, col = x.col, col.ticks = x.col.ticks, padj = x.padj, tcl = - x.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.yaxis <- function (y.labels=seq(-6,6,2), y.labels.pos = 1, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, y.tick.both= FALSE, y.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
axis(1, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cex.axis = y.cex)#
#
if (y.tick.both==TRUE){#
axis(1, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, tick.both=T, x.pos=4)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T, x.pos=4)
erp.yaxis(, y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.yaxis <- function (y.labels=seq(-6,6,2), y.labels.pos = 1, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, y.tick.both= FALSE, y.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
axis(2, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cex.axis = y.cex)#
#
if (y.tick.both==TRUE){#
axis(2, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
plot(word$Fp1, type="l", axes=F)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
par()$mgp
?par
par(mgp=c(3,1,0))
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.yaxis <- function (y.labels=seq(-6,6,2), y.labels.pos = 0, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, y.tick.both= FALSE, y.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
axis(2, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cex.axis = y.cex)#
#
if (y.tick.both==TRUE){#
axis(2, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
par(mgp)
par()$mgp
this function is basically a wrapper for axis with msectopoints embedded and with some little additional features.#
# for finer tuning use directly axis (see also par).#
#
erp.yaxis <- function (y.labels=seq(-6,6,2), y.labels.pos = 0, y.pos = NA, y.tick = seq(-6, 6, 2) , y.outer = F, y.font = NA, y.lty = "solid", y.lwd = 1, y.lwd.ticks = 1, y.col = NULL, y.col.ticks = NULL, y.padj = NA, y.tcl = -0.5, y.tick.both= FALSE, y.cex = 1)#
{#
#
oldpar <- par(no.readonly=TRUE) #
new.mgp = par()$mgp#
# notice that this will affect ALL mgp, but it doesn't matter because afterwards old par are restored#
new.mgp[3]=y.labels.pos#
# disable warning messages#
options(warn=-1)#
par(mgp = new.mgp)#
# re-enable warning messages#
options(warn=1)#
# tick and labels positions#
#
axis(2, at= y.labels, labels=y.labels, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = y.tcl, cex.axis = y.cex)#
#
if (y.tick.both==TRUE){#
axis(2, at= y.labels, labels= FALSE, pos= y.pos, tick = y.tick, outer = y.outer, font = y.font, lty = y.lty, lwd = y.lwd, lwd.ticks = y.lwd.ticks, col = y.col, col.ticks = y.col.ticks, padj = y.padj, tcl = - y.tcl) # NOTICE the minus: it is for plotting in the other direction#
}#
par(oldpar)#
}
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T, x.pos=4)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=F)
plot(word$Fp1, type="l", axes=T, ylim=c(-6,6))
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
plot(word$Fp1, type="l", axes=T, ylim=c(-6,6))
plot(word$Fp1, type="l", axes=T, ylim=c(-6,6), axes=F)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
abline(v=1)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
abline(v=1)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T)
?axis
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.lwd=2,  x.lwd.ticks=2, x.tick.both=T)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T, y.pos = 0)
erp.yaxis( y.lwd=2, y.lwd.ticks=2, y.tick.both=T, y.pos = -1)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6))
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200))
erp.yaxis( y.pos=0)
plot(word$Fp1, type="l", axes=F, ylim=c(-6,6), frame.plot=T)
plot(word$Fp1, type="l",  ylim=c(-6,6))
plot(word$Fp1, axes=F, type="n")
plot(word$Fp1, axes=F, type="n", xlab="", ylab="")
erp.xaxis(dim(word)[1], endmsec=1500, x.labels=seq(-200, 1500, 200), x.pos=0)
library(lmerTest)
citation(lmerTest)
citation("lmerTest")
4.92+4.80.4.64
mean(c(4.92,4.80,4.64))
26 + (0.08*75) - (0.06* 82)
fdagfdagd
asda
gadgad
remove.packages("erpR")
library(erpR)
detach(package:erpR)
remove.packages(erpR)
remove.packages("erpR")
install.packages("erpR", repos="http://r-forge.r-project.org", type="source")
library(rpanel)#
library(akima)#
setwd("~/Desktop/pacchetto erpR/sample_files_erpR")#
#
source('~/Desktop/R files/erpr/pkg/R/msectopoints.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/pointstomsec.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.add.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.infl.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/import.erp.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.latency.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/rearrange.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/grandaverage.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/import.erp.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/scalp.cor.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.peak.R', chdir = TRUE)#
#
source('~/Desktop/R files/erpr/pkg/R/erp.xaxis.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.yaxis.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/erp.t.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/scalp.infl.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/scalp.t.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/topoplot.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/topoplot.palette.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/check.erplist.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/create.mean.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/create.diff.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/cn.R', chdir = TRUE)#
source('~/Desktop/R files/erpr/pkg/R/char2fac.R', chdir = TRUE)#
#
source('~/Desktop/R files/erpr/pkg/R/butterfly.R', chdir = TRUE)
load("/Users/giorgioarcara/Desktop/R files/erpr/pkg/data/ERPsets.RData")
erp.cor <-#
function(base, numbers, electrode, erplist=NULL,startmsec=-200, endmsec=1200, external=NULL, smo=NULL, alpha=0.05, method = c("pearson", "kendall", "spearman"),  sig=NULL,  main=electrode, ...) {#
	# the three dots indicates parameter to be passed to erp.#
#
	# preliminary checks#
	if (is.null(erplist)){#
	stop("an erplist object containing ERP data frames must be specified!", call.=F)#
	}#
	if (length(numbers)!=length(external)){#
	stop("the external variable should have the same length of numbers (of Subjects)")#
	}#
	if (!electrode%in%names(erplist[[1]])) {#
	stop("The electrode specified is not in the data frames contained in the erplist", call.=F)#
	}#
	#### object checks#
	object.names=c(paste(base, numbers, sep=""))#
	if (any(!object.names%in%names(erplist))){#
		missing.objects=object.names[!object.names%in%names(erplist)]#
		missing.object.collist=paste(missing.objects, "\n", sep="")#
		stop("The following objects are not contained in the erplist specified:\n", missing.object.collist, call.=F)#
	}#
		#retrieve the call that can be used with erp and erp.add#
		mycall=match.call()#
		mycall.list=as.list(mycall)#
#
		#create the object for the future call of erp#
		mycall.erp=mycall.list[names(mycall.list)%in%as.list(names(as.list(args(erp))))]#
		#notice the second part of this line of code. Basically I retrive the args of funciton erp, transform in a list. Then I take only the args in call that match#
		# with args of function erp, to avoid to call for args unexpected from the function erp.#
		mycall.erp$el=as.name("el")#
#create the object for the future call of erp.add#
mycall.erp.add=mycall.list[names(mycall.list)%in%c("lty", "smo", "col", "lwd", "startmsec", "endmsec", "interval")]#
	#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=erplist[[paste(base,numbers[i1], sep="")]]	#
	}#
#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], external, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER erp plot#
alldata1=grandaverage(base=base, numbers, erplist=erplist)#
el=alldata1[,electrode]#
		do.call("erp", c(mycall.erp[-1], type="n")) #notice the type="n", tells not to plot (to avoid to plot before the significance bands)#
		# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrode]), col="lightblue", lwd=3)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrode]), col="indianred1",  lwd=3)#
		########################
		do.call("erp.add", mycall.erp.add)#
invisible(alltemp.results)#
}
RT=rnorm(20, mean = 500, sd = 100)#
erp.cor("Exp1_word_subj", numbers=1:20, electrode="Fp1",  erplist=ERPsets, external=RT, startmsec=-200, endmsec=1500, ylim=c(-6,6) )
erp.cor <-#
function(base, numbers, electrode, erplist=NULL,startmsec=-200, endmsec=1200, external=NULL, smo=NULL, alpha=0.05, method = c("pearson", "kendall", "spearman"),  sig=NULL,  main=electrode, ...) {#
	# the three dots indicates parameter to be passed to erp.#
#
	# preliminary checks#
	if (is.null(erplist)){#
	stop("an erplist object containing ERP data frames must be specified!", call.=F)#
	}#
	if (length(numbers)!=length(external)){#
	stop("the external variable should have the same length of numbers (of Subjects)")#
	}#
	if (!electrode%in%names(erplist[[1]])) {#
	stop("The electrode specified is not in the data frames contained in the erplist", call.=F)#
	}#
	#### object checks#
	object.names=c(paste(base, numbers, sep=""))#
	if (any(!object.names%in%names(erplist))){#
		missing.objects=object.names[!object.names%in%names(erplist)]#
		missing.object.collist=paste(missing.objects, "\n", sep="")#
		stop("The following objects are not contained in the erplist specified:\n", missing.object.collist, call.=F)#
	}#
		#retrieve the call that can be used with erp and erp.add#
		mycall=match.call()#
		mycall.list=as.list(mycall)#
#
		#create the object for the future call of erp#
		mycall.erp=mycall.list[names(mycall.list)%in%as.list(names(as.list(args(erp))))]#
		#notice the second part of this line of code. Basically I retrive the args of funciton erp, transform in a list. Then I take only the args in call that match#
		# with args of function erp, to avoid to call for args unexpected from the function erp.#
		mycall.erp$el=as.name("el")#
#create the object for the future call of erp.add#
mycall.erp.add=mycall.list[names(mycall.list)%in%c("lty", "smo", "col", "lwd", "startmsec", "endmsec", "interval")]#
mycall.erp.add$el=as.name("el")#
	#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=erplist[[paste(base,numbers[i1], sep="")]]	#
	}#
#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], external, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER erp plot#
alldata1=grandaverage(base=base, numbers, erplist=erplist)#
el=alldata1[,electrode]#
		do.call("erp", c(mycall.erp[-1], type="n")) #notice the type="n", tells not to plot (to avoid to plot before the significance bands)#
		# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrode]), col="lightblue", lwd=3)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrode]), col="indianred1",  lwd=3)#
		########################
		do.call("erp.add", mycall.erp.add)#
invisible(alltemp.results)#
}
RT=rnorm(20, mean = 500, sd = 100)#
erp.cor("Exp1_word_subj", numbers=1:20, electrode="Fp1",  erplist=ERPsets, external=RT, startmsec=-200, endmsec=1500, ylim=c(-6,6) )
erp.cor <-#
function(base, numbers, electrode, erplist=NULL,startmsec=-200, endmsec=1200, external=NULL, smo=NULL, alpha=0.05, method = c("pearson", "kendall", "spearman"),  sig=NULL,  main=electrode, ...) {#
	# the three dots indicates parameter to be passed to erp.#
#
	# preliminary checks#
	if (is.null(erplist)){#
	stop("an erplist object containing ERP data frames must be specified!", call.=F)#
	}#
	if (length(numbers)!=length(external)){#
	stop("the external variable should have the same length of numbers (of Subjects)")#
	}#
	if (!electrode%in%names(erplist[[1]])) {#
	stop("The electrode specified is not in the data frames contained in the erplist", call.=F)#
	}#
	#### object checks#
	object.names=c(paste(base, numbers, sep=""))#
	if (any(!object.names%in%names(erplist))){#
		missing.objects=object.names[!object.names%in%names(erplist)]#
		missing.object.collist=paste(missing.objects, "\n", sep="")#
		stop("The following objects are not contained in the erplist specified:\n", missing.object.collist, call.=F)#
	}#
		#retrieve the call that can be used with erp and erp.add#
		mycall=match.call()#
		mycall.list=as.list(mycall)#
#
		#create the object for the future call of erp#
		mycall.erp=mycall.list[names(mycall.list)%in%as.list(names(as.list(args(erp))))]#
		#notice the second part of this line of code. Basically I retrive the args of funciton erp, transform in a list. Then I take only the args in call that match#
		# with args of function erp, to avoid to call for args unexpected from the function erp.#
		mycall.erp$el=as.name("el")#
#create the object for the future call of erp.add#
mycall.erp.add=mycall.list[names(mycall.list)%in%c("lty", "smo", "col", "lwd", "startmsec", "endmsec", "interval")]#
mycall.erp.add$el=as.name("el")#
	#### PARTE 1: STATISTICHE PER ELETTRODO #####
if (is.null(sig)){#
element=function(x,row.i){#
	return(x[row.i,])#
	}#
#
alldata1.list=list(NULL)#
alldata2.list=list(NULL)#
for (i1 in 1:length(numbers)){#
	alldata1.list[[i1]]=erplist[[paste(base,numbers[i1], sep="")]]	#
	}#
#
alltemp=list(NULL)#
length(alltemp)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
alltemp.results=list(NULL)#
length(alltemp.results)=dim(alldata1.list[[1]])[1] #creo una lista con tanti elementi quanti i punti del tracciato.#
n.points.time=floor(seq(1,dim(alldata1.list[[1]])[1],dim(alldata1.list[[1]])[1]/10))#
time.elapsed=0#
cat("correlation results computation\n")#
for (k in 1:dim(alldata1.list[[1]])[1]) {#prendo la dimensione di un data.frame qualsiasi#
		temp1=lapply(alldata1.list, function(x) { element(x,k) } )#
		temp1.1=matrix(unlist(temp1), ncol=length(alldata1.list[[1]]), byrow=TRUE)#
		alltemp[[k]][[1]]=temp1.1#
		temp.test.vet=list(NULL)#
		length(temp.test.vet)=dim(alltemp[[k]][[1]])[1]#
		temp.results.vet=NULL#
		for (j in 1:dim(alltemp[[k]][[1]])[2]){#nota:uso dim perché alltemp[[k]][[1]] è una matrice#
		temp.test.vet[[j]]=cor.test(alltemp[[k]][[1]][,j], external, method=method)#
		if(temp.test.vet[[j]]$p.value<alpha){#
			if (temp.test.vet[[j]]$estimate<0){#
				temp.results.vet[j]=-1#
				}#
			if (temp.test.vet[[j]]$estimate>0){#
				temp.results.vet[j]=1#
				}#
			}#
		if(temp.test.vet[[j]]$p.value>=alpha)#
			temp.results.vet[j]=0#
		}#
		alltemp.results[[k]]=temp.results.vet#
		if (k%in%n.points.time){#
			cat(rep(".",10-time.elapsed), "\n")#
			time.elapsed=time.elapsed+1#
			}#
		}#
		cat("\n")#
#
alltemp.results=matrix(unlist(alltemp.results), byrow=TRUE, ncol=dim(alldata1.list[[1]])[2])#
alltemp.results=as.data.frame(alltemp.results)#
names(alltemp.results)=names(alldata1.list[[1]])#
		}#
if (!is.null(sig)){#
	alltemp.results=sig#
	}#
#
##### PARTE 2 CREO DATAFRAME PER erp plot#
alldata1=grandaverage(base=base, numbers, erplist=erplist)#
el=alldata1[,electrode]#
		do.call("erp", c(mycall.erp[-1], type="n")) #notice the type="n", tells not to plot (to avoid to plot before the significance bands)#
		# plotto le bande di significatività di correlazioni negative#
		#######################
		abline(v=grep(-1, alltemp.results[,electrode]), col="lightblue", lwd=3)#
		########################
		# plotto le bande di significatività di correlazioni positive#
		#######################
		abline(v=grep(+1, alltemp.results[,electrode]), col="indianred1",  lwd=3)#
		########################
		do.call("erp.add", mycall.erp.add)#
#invisible(alltemp.results)#
return( c(mycall.erp[-1], type="n"))#
}
RT=rnorm(20, mean = 500, sd = 100)#
erp.cor("Exp1_word_subj", numbers=1:20, electrode="Fp1",  erplist=ERPsets, external=RT, startmsec=-200, endmsec=1500, ylim=c(-6,6) )
install.packages("erpR", repos="http://r-forge.r-project.org", type="source")
library(erpR)
?erpR
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=erplist) #
#
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets) #
#
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))
par(mfrow=c(1,1), pty="s")#
#
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))#
#make a topoplot excluding electrode not found in the built-in list#
#
notfound=topoplot(word, return.notfound=TRUE)#
topoplot(word, startmsec=-200, endmsec=1500, win.ini=400,#
win.end=600, exclude=notfound)
par(mfrow=c(1,2), pty="s")#
#
erp(word$Fp1, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-10,10))#
#make a topoplot excluding electrode not found in the built-in list#
#
notfound=topoplot(word, return.notfound=TRUE)#
topoplot(word, startmsec=-200, endmsec=1500, win.ini=400,#
win.end=600, exclude=notfound)
data(ERPsets)#
#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", #
startmsec=-200, endmsec=1500, erplist=ERPsets)#
#
# Notice that Subject 1 is clearly particularly influential#
# for the average on OZ.
data(ERPsets)#
#
dat=erp.latency(base="Exp1_word_subj", numbers=1:20,#
 win.ini=130, win.end=190, erplist=ERPsets, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), #
name.dep="Ampl", format="long", peak.fun=max)
head(dat)
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long")
data(ERPsets)#
#
dat=erp.mean(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, erplist=ERPsets, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long")
data(ERPsets)#
#
dat=erp.peak(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, erplist=ERPSets, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long", peak.fun=max)
data(ERPsets)#
#
dat=erp.peak(base="Exp1_word_subj", numbers=1:20, #
win.ini=130, win.end=190, erplist=ERPsets, startmsec=-200, endmsec=1500,#
others=c(condition="word", interval="130-190"), name.dep="Ampl", format="long", peak.fun=max)
erp(word$F3, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-6,6))
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=erplist) #
#
erp(word$F3, smo=0, col="blue", startmsec=-200, endmsec=1500, ylim=c(-6,6))
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets)
data(ERPsets)#
#
erp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, #
electrode="Fp1", ylim=c(-10,10),  startmsec=-200, #
endmsec=1500, erplist1=ERPsets, erplist2=ERPsets, #
col=c("blue", "red"))
plot(1, ylim=c(-5,5), xlim=c(0,200), frame.plot=FALSE, #
type="n", axes=FALSE, xlab="", ylab="")#
#
erp.xaxis(200, startmsec=-200, endmsec=1500, #
x.pos=0, x.lwd=2)
plot(1, ylim=c(-5,5), xlim=c(0,200), frame.plot=FALSE, #
type="n", axes=FALSE, xlab="", ylab="")#
#
erp.yaxis(200, startmsec=-200, endmsec=1500, y.pos=0, #
y.lwd=2, y.tick=seq(-4,4,2))
data(iris)#
#
iris2 <- iris[iris$Species!="setosa", ]#
levels(iris2$Species)#
#
iris2[,c("Petal.Width", "Species")]<-factorall(iris2[,c("Petal.Width", "Species")])#
levels(iris2$Species)#
str(iris2)
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets)
x=seq(-5.5,1,0.001)#
#
y=sin(x)+0.3*x#
#
plot(x,y, type="l")#
#
#print an horizontal line intersecting the local maximum#
abline(h=localmax(y))
x=seq(-5.5,1,0.001)#
y=-(sin(x)+0.3*x)#
plot(x,y, type="l")#
abline(h=localmin(y)) #print an horizontal line intersecting the local minimum
msectopoints(120, 500, startmsec=-500, endmsec=1500)
data(ERPsets)#
#
datall=erp.mean(base = "Exp1_word_subj", numbers = 1:20, #
win.ini = 400, win.end = 600, startmsec= -200, endmsec = 1500, format="long", name.dep="Ampl")#
#
datagg=named.agg(Ampl~electrode+Subject, datall, FUN=mean)
data(ERPsets)#
#
datall=erp.mean(base = "Exp1_word_subj", numbers = 1:20, #
win.ini = 400, win.end = 600, erplist=ERPsets, startmsec= -200, #
endmsec = 1500, format="long", name.dep="Ampl")#
#
datagg=named.agg(Ampl~electrode+Subject, datall, FUN=mean)
head(datagg)
# calculate the time in msec corresponding to the point 128 #
# in a segment of 500 points starting from -200 ms #
# and ending at 1500 (500 Hz).#
#
pointstomsec(128, 500, startmsec = - 500, endmsec = 1500)
data(ERPsets)#
#
datwide=erp.mean(base="Exp1_word_subj", numbers=1:20, win.ini=130, #
win.end=190, erplist=ERPsets, startmsec=-200, endmsec=1500, format="wide")#
#
dat.long=rearrange(deps=c(1:32), oth=33:34, dataset=datwide, name.newvar="electrode")
haed(dat.long)
head(dat.long)
data(ERPsets)#
#
#generate an hypothetic external variables#
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, external = RT, smo=0, layout=1, ylim=10, legend=T)
data(ERPsets)#
#
#generate an hypothetic external variables#
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, external = RT, layout=1, e#
rplist=ERPsets, ylim=10, legend=T)
data(ERPsets)#
#
#generate an hypothetic external variables#
RT=rnorm(20, mean=500, sd=200)#
#
scalp.cor("Exp1_word_subj", 1:20, external = RT, layout=1, #
erplist=ERPsets, ylim=10, legend=T)
data(ERPdatasets)#
#
# Notice that Subject 1 is clearly particularly influential for the average on OZ.#
scalp.infl(base="Exp1_word_subj", numbers=1:20, layout=1, startmsec=-200, endmsec=1500, erplist=ERPsets)
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", #
startmsec=-200, endmsec=1500, erplist=ERPsets)#
#
# Notice that Subject 1 is clearly particularly influential#
# for the average on OZ.
\name{erp.infl}#
\alias{erp.infl}#
%- Also NEED an '\alias' for EACH other topic documented here.#
\title{#
inspect the influence of a subject on the average (single electrode).#
}#
\description{#
This function returns a diagnostic plot to investigate the influence of a given ERP data frame on the grandaverage of a series of ERP data frames. A GUI is provided to explore the effect of removing a data frame (that is expected to be associated with a Subject) on the grandaverage. Two plots are superposed: the original grandaverage and the average removing the subject selected via the GUI.#
}#
#
\usage{ #
	erp.infl(base, numbers, electrode, erplist=NULL,  startmsec=-200, #
	endmsec=1200, smo=NULL, outnumber=1, lwd=1, lty=1,  ...)#
}#
#
\arguments{#
\item{base}{#
a string indicating the beginning of the name of the \code{data.frame} containing the ERP data.#
}#
  \item{numbers}{#
the numbers of the subjects to be averaged by the function.#
}#
#
  \item{electrode}{#
the electrode to be plotted.#
}#
#
  \item{erplist}{#
a list containing the ERP data frames specified in \code{base} and \code{numbers}.#
}#
#
  \item{startmsec}{#
the start time (in ms) of the ERP vector.#
}#
  \item{endmsec}{#
the end time (in ms) of the ERP vector.#
}#
#
  \item{smo}{#
the smoothing parameter to apply (see \code{\link{smooth.spline}}). Default is \code{NULL} and no smoothing is applied.#
}#
#
\item{outnumber}{#
The number of the subject that will be initially removed from the averaged (this value could be changed also via the GUI).#
}#
#
  \item{lwd}{#
line width.#
}#
  \item{lty}{#
line type.#
}#
#
\item{\ldots}{#
further parameters to be passed to \code{erp} function called within \code{erp.infl}.#
}#
#
}#
#
\details{#
The function requires the package \code{rpanel}#
}#
#
\value{#
The function returns a plot of a single electrode showing the influence of a subject on the grandaverage.#
}#
\author{#
Giorgio Arcara#
}#
\seealso{#
\code{\link{erp}}, \code{link{scalp.infl}}#
}#
\examples{#
#
data(ERPsets)#
#
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", #
startmsec=-200, endmsec=1500, erplist=ERPsets)#
#
# Notice that Subject 1 is clearly particularly influential#
# for the average on OZ.#
}
erp.infl <-#
function(base, numbers, electrode, erplist=NULL,  startmsec=-200, endmsec=1200, smo=NULL, outnumber=1, lwd=1, lty=1,  ...){#
#
	# preliminary checks#
	if (is.null(erplist)){#
	stop("an erplist object containing ERP data frames must be specified!", call.=F)#
	}#
	if (!electrode%in%names(erplist[[1]])) {#
	stop("The electrode specified is not in the data frames contained in the erplist", call.=F)#
	}#
	#### object checks#
	object.names=paste(base, numbers, sep="")#
	if (any(!object.names%in%names(erplist))){#
		missing.objects=object.names[!object.names%in%names(erplist)]#
		missing.object.collist=paste(missing.objects, "\n", sep="")#
		stop("The following objects are not contained in the erplist specified:\n", missing.object.collist, call.=F)#
	}#
#retrieve the call that can be used with erp and erp.add#
mycall=match.call()#
mycall.list=as.list(mycall)#
#
#create the object for the future call of erp#
mycall.erp=mycall.list[names(mycall.list)%in%as.list(names(as.list(args(erp))))]#
#notice the second part of this line of code. Basically I retrive the args of funciton erp, transform in a list. Then I take only the args in call that match#
# with args of function erp, to avoid to call for args unexpected from the function erp.#
mycall.erp$el=as.name("average")#
#
#create the object for the future call of erp#
mycall.erp.add=mycall.list[names(mycall.list)%in%c("lty", "smo", "col", "lwd")]#
mycall.erp.add=append(mycall.erp.add, as.name("average.excl"))#
names(mycall.erp.add)[length(mycall.erp.add)]="el"#
mycall.erp.add$col = "red"#
mycall.erp.add$lwd = 2 #substitute the lwd for the call of erp.add#
# la funzione contiene all'interno una funzione che crea il panel. Questa funzione a sua volta contiene la funzione scalp.infl.endo, che è quella che effettivamente fa il grafico appoggiandosi alla funzione scalp.endo. #
erp.infl.panel=function(panel)#
	{#
		erp.infl.endo=function(base, numbers, electrode, outline, smo=0 , col="black", startmsec=-200, endmsec=1000, interval=c(startmsec, endmsec), step=200, verticals=NULL,horizontals=NULL, x.axis="default", ylim=c(-10,10), lwd=1, lty=1, out.col="red", erplist)#
	{#
		average.temp=erplist[[paste(base,numbers[1],sep="")]][[electrode]]#
		for (i in 2:length(numbers))#
		{#
			average.temp=average.temp+erplist[[paste(base,numbers[i],sep="")]][[electrode]]	#
		}#
		average=average.temp/length(numbers)#
		if (!is.null(smo)){#
			average=smooth.spline(erp, spar=smo)$y#
		}#
#
		## add to the call of erp the electrode#
		do.call("erp", mycall.erp[-1]) #notice the -1. It is to remove the name of the function from the call list.#
		# very important! in update of rpanel the outline parameter becomes a character#
		# the line below is fundamental#
		outline=as.numeric(outline)#
		average.excl=(average.temp-erplist[[paste(base, numbers[outline],sep="")]][[electrode]])/(length(numbers)-1)		#
		do.call("erp.add", mycall.erp.add)#
	legend("topright", legend=c("Average all", paste("Average no subj", outline)), pch=15, col=c(col,out.col), pt.bg=c(1:6), cex=1.2)#
		}							#
		erp.infl.endo(base=base, numbers=numbers, electrode=electrode, outline=panel$outnumber, smo=smo, startmsec=startmsec, endmsec=endmsec, erplist=erplist)#
		panel#
		}#
		panel <- rp.control() #se volessi creare più pannelli allora dovrei aggiungere un'altro panel.#
       rp.listbox(panel, outnumber, numbers, labels=as.character(numbers), action = erp.infl.panel, initval=numbers[1], title="Subject")#
	   rp.do(panel, erp.infl.panel)#
   }
erp.infl(base="Exp1_word_subj", numbers=1:20, electrode="OZ", #
startmsec=-200, endmsec=1500, erplist=ERPsets)#
#
# Notice that Subject 1 is clearly particularly influential#
# for the average on OZ.
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets)#
#
nonword=grandaverage("Exp1_nonword_subj", 1:20, erplist=ERPsets)#
#
scalp(list(word), smo=0, layout=1, ylim=10)#
#
scalp(list(word, nonword), smo=0, layout=1, ylim=10, legend=T)
data(ERPsets)#
#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, #
layout=1, ylims=10, startmsec=-200, endmsec=1500, color.list=c("blue", "red"))
data(ERPsets)#
#
scalp.t("Exp1_word_subj", "Exp1_nonword_subj", 1:20, 1:20, smo=0, #
layout=1, ylims=10, startmsec=-200, endmsec=1500, color.list=c("blue", "red"), erplist1=ERPsets, erplist2=ERPsets)
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets)#
#
# check if some electrodes are not present in the list#
# and create an object with these electrode names.#
notfound=topoplot(word, return.notfound=TRUE)#
#
#define a layout for#
mat=matrix(c(1,2), 1, 2, byrow=TRUE)#
#
layout(mat, widths=c(0.8, 0.2))#
#
#make a topoplot excluding not found electrode#
par(pty="s")#
topo.data=topoplot(word, startmsec=-200, endmsec=1500, win.ini=400, #
win.end=600, exclude=notfound)#
#
#draw the palette on a new empty plot.#
par(pty="m", mar=c(0,0,0,0))#
plot.new()#
topoplot.palette(cols=topo.data$palette, #
palette.lim=topo.data$zlim, p.height=0.6)
data(ERPsets)#
#
word=grandaverage("Exp1_word_subj", 1:20, erplist=ERPsets)#
#
# check if some electrodes are not present in the list #
# and create an object with these electrode names.#
#
notfound=topoplot(word, return.notfound=TRUE)#
#
#make a topoplot excluding not found electrode#
topoplot(word, startmsec=-200, endmsec=1500, win.ini=400,#
win.end=600, exclude=notfound)
# simulate some subjects#
subjRT=rnorm(20, 500, 100)#
#
#simulate the effects of three experimental conditions for each subject#
condA=rnorm(20, 50, 10)#
condB=rnorm(20, -40, 10)#
condC=rnorm(20, 20, 10)#
#
#create a data frame#
dat=data.frame(Subject=rep(1:20,3), #
condition=c(rep("A", 20), rep("B", 20), rep("C", 20)), #
RT=c(subjRT+condA, subjRT+condB, subjRT+condC ))
tpairs(dat, "condition", "all", "RT", "Subject", var.equal=TRUE)
dim(word)
head(word)
#### funzione per calcolare il sampling rate (in Hz) dagli oggetti che uso tipicamente in R per eeg#
#####
#
sampling.rate=function(x, baseline=-200, total.length=1200){#
	samp.rate=((dim(x)[1]-1)*1000)/(-baseline+total.length)#
	return(samp.rate)#
}
sampling.rate(128, -200, 1500)
sampling.rate(426, -200, 1500)
sampling.rate(word, -200, 1500)
library(languageR)
pvals.fnc
erpR
erp
rm(list=ls8)
rm(list=ls())
erp
pvals.fnc
dir()
a=dir()
a
